<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>lufei&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://nijiehaha.github.io/"/>
  <updated>2020-01-22T03:16:10.653Z</updated>
  <id>https://nijiehaha.github.io/</id>
  
  <author>
    <name>路小飞</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【译】Objective-C Direct Methods</title>
    <link href="https://nijiehaha.github.io/2020/01/20/%E3%80%90%E8%AF%91%E3%80%91Objective-C-Direct-Methods/"/>
    <id>https://nijiehaha.github.io/2020/01/20/%E3%80%90%E8%AF%91%E3%80%91Objective-C-Direct-Methods/</id>
    <published>2020-01-20T05:29:37.000Z</published>
    <updated>2020-01-22T03:16:10.653Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h1><p><a href="https://nshipster.com/direct/#objc_direct-propertydirect-and-objc_direct_members" target="_blank" rel="noopener">Objective-C Direct Methods</a></p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>当听说OC引入新功能的时候，我已经很难感到兴奋了。最近的一些关于OC的改进，都是为了服务于和Swift的互通，而不是关于OC这门语言本身了（看看<a href="https://developer.apple.com/swift/blog/?id=25" target="_blank" rel="noopener">nullabiltiy</a>和<a href="https://developer.apple.com/documentation/swift/imported_c_and_objective-c_apis/using_imported_lightweight_generics_in_swift" target="_blank" rel="noopener">lightwight generics</a>）</p><p>因此，当我了解到<a href="https://reviews.llvm.org/D69991" target="_blank" rel="noopener">最近的Clang的合并补丁</a>为OC的方法添加了直接分配的机制的时候，感到十分的兴奋。</p><p>这种新功能的起源还不是很清楚；能得到的线索止于苹果内部的 Radar 号（2684889），除了能借此推出这项功能的相对年龄（估计是本世纪初的什么时候），就得不到更多的信息了。幸好，这个功能拥有充足的文档和测试范围，能让我们很好的了解它的原理。(对实施者Pierre Habouzit，审核经理John McCall和其他LLVM贡献者表示由衷的感谢)</p><p>本周在NSHipster上，我们借此机会回顾了OC方法的分派，并试图了解这一新语言功能对未来代码库的潜在影响。</p><p>(<strong>Direct</strong>方法最早可能会出现在Xcode 11.x上，但很可能会在WWDC 2020上宣布。)</p><p>要了解Direct方法的重要性，您需要了解一些有关OC运行时的知识。但是，在此之前，让我们从oop本身的起源开始我们的讨论：</p><h1 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h1><p>Alan Kay在1960年初期创造了这个词，之后，在Adele Goldberg，Dan Ingalls和他在Xerox parc的其他同事的帮助下，Kay通过创建Smalltalk编程语言，在70年代将该想法付诸实践。</p><p>(在此期间，Xerox PARC 的研究人员还开发了 Xerox Alto，这将成为苹果Macintosh和所有其他GUI计算机的灵感来源)</p><p>在1980年代，Brad Cox和Tom Love开始研究OC的第一个版本，这是一种语言，旨在采用Smalltalk的面向对象范式，并在C的坚实基础上加以实施。 90年代，该语言成为NeXT（后来成为Apple）的官方语言。</p><p>对于我们这些在iPhone时代开始学习OC的人来说，该语言通常被视为另一项苹果专有技术，是该公司“Not invented here”文化的众多，晦涩的副产品之一。然而，我们并不能说 Objective-C 只是「面向对象的 C」而已，它是最早的几个面向对象语言之一，像其他语言一样，都有着强烈的面向对象特质。</p><p>现在，oop是什么意思？这是个好问题。上世纪90年代的炒作周期使该词几乎毫无意义。但是，就我们今天的目的而言，让我们集中讨论Alan Kay在1998年写的一句话：</p><blockquote><p>I’m sorry that I long ago coined the term “objects” for this topic because it gets many people to focus on the lesser idea. The big idea is “messaging”</p></blockquote><h1 id="动态分派和OC运行时"><a href="#动态分派和OC运行时" class="headerlink" title="动态分派和OC运行时"></a>动态分派和OC运行时</h1><p>在OC中，程序由一组对象组成，这些对象通过传递依次调用方法或函数的消息而彼此交互。消息传递的这种行为由方括号语法表示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[someObject aMethod:withAnArgument];</span><br></pre></td></tr></table></figure><p>编译OC代码后，消息发送将转换为对名为<code>objc_msgSend</code>的函数的调用（字面意思是“将消息发送至带有参数的某个对象”）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objc_msgSend(object, @selector(message), withAnArgument);</span><br></pre></td></tr></table></figure><ul><li><p>第一个参数是接收方（实例方法本身）</p></li><li><p>第二个参数是_cmd：选择器或方法的名称</p></li><li><p>任何方法参数都作为附加函数参数传递</p></li></ul><p>Objc_msgSend负责确定响应此消息而调用哪个基础实现，该过程称为方法分派。</p><p>在Objective-C中，每个类维护一个调度表来解析在运行时发送的消息。调度表中的每个条目都是一个方法，该方法将选择器（SEL）键入相应的实现（IMP），该实现是指向C函数的指针。当对象收到消息时，它查询其类的调度表。如果可以找到选择器的实现，则调用关联的函数。否则，对象将查询其超类的调度表。这将继续沿继承链向上进行，直到找到匹配项或根类（NSObject）认为选择器无法识别。</p><p>(更不用说OC还可以让您做诸如替换方法实现和在运行时动态创建新类之类的事情。您可以做的事相当宽广。)</p><p>如果您认为所有这些间接听起来都需要大量工作，从某种意义上来说，那是对的！</p><p>如果您的代码中有一条常使用的代码调用路径，比如一个频繁被调用的消耗巨大的方法，那么您可以想象避免所有这些间接操作会有所益处。为此，一些开发人员已使用C函数作为替换动态分派的一种方式。</p><h1 id="用C函数直接分派"><a href="#用C函数直接分派" class="headerlink" title="用C函数直接分派"></a>用C函数直接分派</h1><p>正如我们在<code>objc_msgSend</code>中所看到的，任何方法调用都可以通过将隐式<code>self</code>作为第一个参数传递而由等效函数表示。</p><p>例如，考虑使用常规的动态分派方法对OC类进行以下声明。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@interface MyClass: NSObject</span><br><span class="line">- (void)dynamicMethod;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>如果开发人员希望在<code>MyClass</code>上实现某些功能, 但是不要遍历所有消息来发送，那么，他们可以声明一个静态的C函数，该函数将<code>MyClass</code>的实例作为参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static void directFunction(MyClass *__unsafe_unretained object);</span><br></pre></td></tr></table></figure><p>以下是每种方法的调用方式的展示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MyClass *object = [[[MyClass] alloc] init];</span><br><span class="line"></span><br><span class="line">// Dynamic Dispatch</span><br><span class="line">[object dynamicMethod];</span><br><span class="line"></span><br><span class="line">// Direct Dispatch</span><br><span class="line">directFunction(object);</span><br></pre></td></tr></table></figure><h1 id="Direct-方法"><a href="#Direct-方法" class="headerlink" title="Direct 方法"></a>Direct 方法</h1><p>Direct方法具有常规OC方法的外观，但是具有C函数的行为。调用Direct方法时，它直接调用其基础实现，而不是通过objc_msgSend。</p><p>有了这个新的LLVM补丁，您现在可以有选择性地注释掉Objective-C方法，从而避免使用动态分派。</p><h1 id="objc-direct-property-direct-和-objc-direct-members"><a href="#objc-direct-property-direct-和-objc-direct-members" class="headerlink" title="objc_direct, @property(direct), 和 objc_direct_members"></a>objc_direct, @property(direct), 和 objc_direct_members</h1><p>要使实例或类方法使用Direct分派，可以使用objc_direct<a href="https://nshipster.com/__attribute__/" target="_blank" rel="noopener">Clang属性</a>对其进行标记。同样，可以通过使用<code>direct</code>声明Object-C属性的方法来使其实现Direct分派。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@interface MyClass: NSObject</span><br><span class="line">@property(nonatomic) BOOL dynamicProperty;</span><br><span class="line">@property(nonatomic, direct) BOOL directProperty;</span><br><span class="line"></span><br><span class="line">- (void)dynamicMethod;</span><br><span class="line">- (void)directMethod __attribute__((objc_direct));</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>根据我们的计算，<code>direct</code>的添加使<code>@property</code>属性的总数达到16：</p><ul><li><code>getter</code> 和 <code>setter</code></li><li><code>readwrite</code> 和 <code>readonly</code></li><li><code>atomic</code> 和 <code>nonatomic</code></li><li><code>weak</code>, <code>strong</code>, <code>copy</code>, <code>retain</code>，和 <code>unsafe_unretained</code></li><li><code>nullable</code>, <code>nonnullable</code>, 和 <code>null_resttable</code></li><li><code>class</code></li></ul><p>当使用<code>objc_direct_members</code>属性注释类别或类扩展的<code>@interface</code>时，其中包含的所有方法和属性声明都将视为direct的，除非该类事先声明过。</p><blockquote><p>您无法使用<code>objc_direct_members</code>属性注释原始类接口。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((objc_direct_members))</span><br><span class="line">@interface MyClass ()</span><br><span class="line">@property (nonatomic) BOOL directExtensionProperty;</span><br><span class="line">- (void)directExtensionMethod;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>用<code>objc_direct_members</code>注释<code>@implementation</code>具有相似的效果，会使未先前声明的成员被视为direct成员，包括任何由属性综合产生的隐式方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((objc_direct_members))</span><br><span class="line">@implementation MyClass</span><br><span class="line">- (BOOL)directProperty &#123;…&#125;</span><br><span class="line">- (void)dynamicMethod &#123;…&#125;</span><br><span class="line">- (void)directMethod &#123;…&#125;</span><br><span class="line">- (void)directExtensionMethod &#123;…&#125;</span><br><span class="line">- (void)directImplementationMethod &#123;…&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><blockquote><p>动态方法不能在子类中被直接方法覆盖，direct方法也不能被覆盖。<br>  协议不能声明direct方法要求，而类也不能使用direct方法来实现协议要求。</p></blockquote><p>之前的示例已经示范过如何使用了，我们可以看到在调用方式上direct方法和动态方法是如何区分的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MyClass *object = [[[MyClass] alloc] init];</span><br><span class="line"></span><br><span class="line">// Dynamic Dispatch</span><br><span class="line">[object dynamicMethod];</span><br><span class="line"></span><br><span class="line">// Direct Dispatch</span><br><span class="line">[object directMethod];</span><br></pre></td></tr></table></figure><p>对于我们当中注重性能的开发人员而言，direct方法似乎是精彩的方案。但是有一个小转折：</p><p><strong><em>在大多数情况下，direct方法可能不会带来明显的性能优势。</em></strong></p><p>事实证明，<code>objc_msgSend</code>非常快。由于积极的缓存，广泛的低级优化以及现代处理器的固有性能，<code>objc_msgSend</code>的开销非常低。</p><p>我们早已可以将iPhone硬件合理地描述为资源受限的环境了。因此，除非苹果正在为新的嵌入式平台做准备（AR眼镜？），否则我们对苹果在2019年实施OC的<strong>Direct</strong>方法的最合理的解释是性能以外的原因。</p><h1 id="隐藏的动机"><a href="#隐藏的动机" class="headerlink" title="隐藏的动机"></a>隐藏的动机</h1><p>当将OC方法标记为direct方法时，其实现可以隐藏可见性。也就是说，direct方法只能在同一模块内调用。它甚至不会出现在OC运行时中。</p><p>隐藏可见性有两个直接的优点：</p><ul><li>较小的二进制文件大小</li><li>没有外部调用</li></ul><p>没有外部可见性，也没有从OC运行时动态调用它们的方法，直接方法实际上是私有方法。</p><blockquote><p>如果您想使用direct分派，但仍然希望使您的API可以从外部访问，则可以将其包装在C函数中。                          </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static inline void performDirectMethod(MyClass *__unsafe_unretained object) &#123;</span><br><span class="line">    [object directMethod];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尽管Apple可以使用隐藏可见性来防止混乱和私有API的使用，但这似乎并不是主要动机。</p><p>根据实施此功能的Pierre所说，此优化的主要好处是减少了代码大小。据报道，未使用的O元数据的权重可占已编译二进制文件中<code>__text</code>部分的5 – 10％。</p><p>您可以想象，从现在起到明年的开发者大会，可以有几个工程师遍历每个SDK框架，用<code>objc_direct</code>注释私有方法，并用<code>objc_direct_members</code>注释私有类，这是逐步加强其SDK的轻量级方法。</p><p>如果的确如此，那么我们对Objective-C的新功能添加的理由也持怀疑态度。我认为既然不是服务于swift语言， 那应该就是服务于苹果公司的吧。尽管这个功能在编程历史和Apple本身中占有重要地位，但已经很难不把OC视为历史了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原文&quot;&gt;&lt;a href=&quot;#原文&quot; class=&quot;headerlink&quot; title=&quot;原文&quot;&gt;&lt;/a&gt;原文&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://nshipster.com/direct/#objc_direct-propertydirect-and-
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>知识小集</title>
    <link href="https://nijiehaha.github.io/2019/12/18/%E7%9F%A5%E8%AF%86%E5%B0%8F%E9%9B%86/"/>
    <id>https://nijiehaha.github.io/2019/12/18/%E7%9F%A5%E8%AF%86%E5%B0%8F%E9%9B%86/</id>
    <published>2019-12-18T08:14:37.000Z</published>
    <updated>2020-01-19T05:23:03.375Z</updated>
    
    <content type="html"><![CDATA[<p>这里记录一些单个小知识，当备忘录用了，会持续更新，嘻嘻嘻。</p><blockquote><p>持续交付的神器，<a href="https://docs.fastlane.tools/" target="_blank" rel="noopener">fastlane</a>真是太方便好用了，一个<code>gym</code>选项就满足了我的所有需求，苦笑～～～</p></blockquote><blockquote><p>Postman好人性化啊，关于multipart/form-data和application/x-www-form-urlencoded的小区别～～～</p></blockquote><blockquote><p><strong>PHImageManager</strong>的<code>requestImageData</code>有一个巨坑（我没找到比较好的办法），就是无论如何都会阻塞主线程一会儿，但是只要在当前线程<code>sleep</code>任意时间，就没事了，相当硬核，或者直接使用<code>requestImage</code>这个api，速度快，<code>PHImageRequestOptions</code>设置成同步，效果佳，很香</p></blockquote><blockquote><p>hexo在远程git仓库，更改密码，无法推送，也不弹出密码，用户名的情况下，可以考虑删除hexo根目录下的<code>.deploy</code>文件夹</p></blockquote><blockquote><p>iOS，实现镂空的效果，可以使用<code>CALayer</code>的<a href="https://developer.apple.com/documentation/quartzcore/calayer/1410861-mask" target="_blank" rel="noopener">mask</a>和<a href="https://developer.apple.com/documentation/quartzcore/calayer/1410773-contents" target="_blank" rel="noopener">contents</a>，或者直接使用<code>UIView</code>的<a href="https://developer.apple.com/documentation/uikit/uiview/1622557-mask" target="_blank" rel="noopener">mask</a>，我自己觉得最简单的是使用<code>UIBezierPath</code>的方法<a href="https://developer.apple.com/documentation/uikit/uibezierpath/1624348-reversing" target="_blank" rel="noopener">reversing()</a>，这个方法实现镂空，我个人觉得最巧妙了，当然还有其他的方法，都有点麻烦，比如利用<code>drawRect</code>来渲染绘制出来</p></blockquote><blockquote><p><code>swift</code>5.0之后，关于<a href="https://deerchao.cn/tutorials/regex/regex.htm" target="_blank" rel="noopener">正则表达式</a>，有一个新的很方便的语法糖<code>#</code>，举个例子，类似这样：<code>#&quot;\dlufei\d&quot;#</code>，不需要再使用转移字符了，点赞</p></blockquote><blockquote><p>在<code>swift</code>中，要想使用正则表达式，一般使用<a href="https://developer.apple.com/documentation/foundation/nsregularexpression" target="_blank" rel="noopener">NSRegularExpression</a>，还可以使用<code>String</code>的<a href="https://developer.apple.com/documentation/foundation/nsstring/1410144-range" target="_blank" rel="noopener">range(of:)</a>接口，<a href="https://nshipster.com/swift-regular-expressions/" target="_blank" rel="noopener">参考Mattt大神的文章</a></p></blockquote><blockquote><p>接上条，还是关于正则表达式，还可以使用<a href="https://docs.swift.org/swift-book/ReferenceManual/Patterns.html" target="_blank" rel="noopener">模式匹配（pattern-match）</a>来为<code>NSRegularExpression</code>提供方便的扩展，<a href="https://swifter.tips/pattern-match/" target="_blank" rel="noopener">参考喵神文章</a></p></blockquote><blockquote><p><code>swift</code>的<a href="https://swift.org/core-libraries/#foundation" target="_blank" rel="noopener">核心库</a>是包含<em>Foundation</em>框架的，不过这个库是独立于<code>Objective-C runtime</code>来使用swift重新构建的</p></blockquote><blockquote><p><strong>Swift</strong>中的<a href="https://developer.apple.com/documentation/swift/range" target="_blank" rel="noopener">Range</a>，表示从下限到上限（但不包括上限）的半开间隔，举个例子：<code>0.0..&lt;5.0</code>，这就是一个简单的<strong>Range</strong>，<a href="https://developer.apple.com/documentation/swift/closedrange" target="_blank" rel="noopener">ColsedRange</a>, 表示一个从下限到上限（包括上限）的间隔，举个例子：<code>0...5</code>，<code>Partial</code>开头的区间表示单方向的区间</p></blockquote><blockquote><p><strong>Swift</strong>中的语法糖，形如<code>String[Range]</code>，可以直接截取字符串，这是在标准库里，<code>Sring</code>中专门实现了<strong>subscript(r:Range&lt;String.Index&gt;) -&gt; subString</strong></p></blockquote><blockquote><p>iOS9.0以后，<a href="https://developer.apple.com/documentation/safariservices/sfsafariviewcontroller" target="_blank" rel="noopener">SFSafariViewController</a>可以实现和safari的cookies共享，这个其实就给需要实现下载归因记录的需求的人（这个需求，还可以通过ip，网络状况，设备信息来匹配的方法，来判断来源，不管哪种方法都是需要下载并打开应用才行），提供了另一个思路，可以通过cookies来追踪来源，js的唤醒方法一般是用<a href="https://www.w3schools.com/js/js_window_location.asp" target="_blank" rel="noopener">Location</a>方法，app端则加载一个SFSafariViewController，大概是这样，当然这只是一个思路，貌似这个方案有被拒绝的可能，<a href="https://developer.apple.com/app-store/review/guidelines/#legal" target="_blank" rel="noopener">审核指南</a>，可以参考下下</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这里记录一些单个小知识，当备忘录用了，会持续更新，嘻嘻嘻。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;持续交付的神器，&lt;a href=&quot;https://docs.fastlane.tools/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;fastlane&lt;
      
    
    </summary>
    
    
      <category term="杂七杂八" scheme="https://nijiehaha.github.io/categories/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"/>
    
    
      <category term="杂七杂八" scheme="https://nijiehaha.github.io/tags/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"/>
    
  </entry>
  
  <entry>
    <title>Kingfisher源码阅读:命名空间</title>
    <link href="https://nijiehaha.github.io/2019/12/16/Kingfisher%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/"/>
    <id>https://nijiehaha.github.io/2019/12/16/Kingfisher%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/</id>
    <published>2019-12-16T01:17:42.000Z</published>
    <updated>2019-12-16T02:37:35.051Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>拜读喵神的<a href="https://github.com/onevcat/Kingfisher" target="_blank" rel="noopener">Kingfisher</a>，学习Swift，第一个就是这个<code>kf</code>命名空间的实现，好酷。</p><p>以前写OC的时候，给系统方法扩展，官方都是推荐使用增加<code>前缀_</code>的方式，swift的推出，改变了这种情况，因为语言特性和苹果力荐的面向协议编程，有了更酷的实现。</p><ul><li><p><a href="https://github.com/onevcat/Kingfisher/blob/master/Sources/General/Kingfisher.swift" target="_blank" rel="noopener">喵神的实现</a></p></li><li><p><a href="https://github.com/apple/swift/blob/master/stdlib/public/core/LazySequence.swift" target="_blank" rel="noopener">swift中的lazySequence</a></p></li></ul><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>实现一个包裹泛型Base类的Struct或者Class，实现<code>Protocol</code> 和你想要的命名空间，将 Protocol 加载到所需的 Base 类并通过<code>Extension + where Base</code>实现 Base 类的特定代码</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>参考上面的源码和思路，我自己试着写了一遍，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">/// 包裹NJBase的struct</span><br><span class="line">struct NijieWrapper&lt;NJBase&gt; &#123;</span><br><span class="line">    </span><br><span class="line">    let base:NJBase</span><br><span class="line">    </span><br><span class="line">    init(_ base: NJBase) &#123;</span><br><span class="line">        </span><br><span class="line">        self.base = base</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// 实现协议</span><br><span class="line">protocol NijieCompatible: AnyObject &#123;&#125;</span><br><span class="line">extension NijieCompatible &#123;</span><br><span class="line">    </span><br><span class="line">    var nj:NijieWrapper&lt;Self&gt; &#123;</span><br><span class="line">        </span><br><span class="line">        get &#123; return NijieWrapper(self) &#125;</span><br><span class="line">        set &#123;&#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// 为UIImageView添加扩展</span><br><span class="line">extension UIImageView: NijieCompatible &#123;&#125;</span><br><span class="line">extension NijieWrapper where NJBase: UIImageView &#123;</span><br><span class="line">    </span><br><span class="line">    func setNijieImage(image:UIImage? = nil) &#123;</span><br><span class="line">        </span><br><span class="line">        base.image = image</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现协议的时候，之所以使用扩展，是因为需要给所有遵守协议的类型提供默认实现。</p><p>使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let imageView = UIImageView()</span><br><span class="line">imageView.frame = CGRect(x: 100, y: 100, width: 100, height: 100)</span><br><span class="line">imageView.nj.setNijieImage(image: UIImage(named: &quot;test123&quot;))</span><br></pre></td></tr></table></figure><h1 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h1><p>这样子，命名空间就实现了，感恩swift</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;拜读喵神的&lt;a href=&quot;https://github.com/onevcat/Kingfisher&quot; target=&quot;_blank&quot; r
      
    
    </summary>
    
    
      <category term="iOS" scheme="https://nijiehaha.github.io/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://nijiehaha.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>语义分析</title>
    <link href="https://nijiehaha.github.io/2019/12/04/%E8%AF%AD%E4%B9%89%E5%88%86%E6%9E%90/"/>
    <id>https://nijiehaha.github.io/2019/12/04/%E8%AF%AD%E4%B9%89%E5%88%86%E6%9E%90/</id>
    <published>2019-12-04T02:03:29.000Z</published>
    <updated>2019-12-04T06:31:42.503Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>学习了<em>词法分析(Lexical Analysis)</em>和<em>语法分析(Syntactic Analysis, or Parsing)</em>，基本上就可以用自己熟悉的语言来实现一门简单的脚本语言了，可以为自己的语言实现想要的操作符和关键字，简单的运算，也可以处理语法错误，我给自己的语言取名叫<code>njscript</code>，并且实现REPL交互环境。</p><p>当然，这玩意还是连玩具都算不上，因为我的算法能力太差，脑袋太笨，所以在<code>njscript</code>涉及到算法的时候，就打了退堂鼓，所以就跳过开始学习<em>语义分析(Semantic Analysis)</em></p><h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><p>简单来说，语义分析就是要让计算机理解我们的真实意图，把一些模棱两可的地方消除掉。</p><p>语义分析的职责：</p><ul><li><p>某个表达式的计算结果是什么数据类型？如果有数据类型不匹配的情况，是否要做自动转换？</p></li><li><p>如果在一个代码块的内部和外部有相同名称的变量，我在执行的时候到底用哪个？ 就像“我喜欢又聪明又勇敢的你”中的“你”，到底指的是谁，需要明确。</p></li><li><p>在同一个作用域内，不允许有两个名称相同的变量，这是唯一性检查。你不能刚声明一个变量 a，紧接着又声明同样名称的一个变量 a，这就不允许了。</p></li></ul><p>语义分析基本上就是做这样的事情，也就是根据语义规则进行分析判断。</p><p>语义分析工作的某些成果，会作为属性标注在抽象语法树上。</p><p>在这个树上还可以标记很多属性，有些属性是在之前的两个阶段就被标注上了，比如所处的源代码行号，这一行的第几个字符。这样，在编译程序报错的时候，就可以比较清楚地了解出错的位置。</p><p>做了这些属性标注以后，编译器在后面就可以依据这些信息生成目标代码了。</p><h1 id="作用域-Scope"><a href="#作用域-Scope" class="headerlink" title="作用域 (Scope)"></a>作用域 (Scope)</h1><p>作用域是指计算机语言中变量、函数、类等起作用的范围。</p><p>C语言的作用域的规律大概是这样：</p><ul><li><p>变量的作用域有大有小，外部变量在函数内可以访问，而函数中的本地变量，只有本地才可以访问。</p></li><li><p>变量的作用域，从声明以后开始。</p></li><li><p>在函数里，我们可以声明跟外部变量相同名称的变量，这个时候就覆盖了外部变量。</p></li></ul><p>C语言里还有块作用域的概念，就是用花括号包围的语句，if 和 else 后面就跟着这样的语句块。块作用域的特征跟函数作用域的特征相似，都可以访问外部变量，也可以用本地变量覆盖掉外部变量。</p><p>不过，各个语言在这方面的设计机制是不同的，比如javascript是没有块作用域的，在块里和 for 语句试图重新定义变量 b，语法上是允许的，但我们每次用到的其实是同一个变量。</p><p>虽然各门语言设计上的特性是不同的，但在运行期的机制都很相似，比如都会用到栈和堆来做内存管理。</p><h1 id="生存期-Extent"><a href="#生存期-Extent" class="headerlink" title="生存期 (Extent)"></a>生存期 (Extent)</h1><p>生存期是变量可以访问的时间段，也就是从分配内存给它，到收回它的内存之间的时间。</p><p>本地变量是用栈来管理的，所以它的作用域和生存期是一致的，出了作用域，生存期也就结束了，变量所占用的内存也就被释放了。</p><p>但也有一些情况，变量的生存期跟语法上的作用域不一致，比如在堆中申请的内存，退出作用域以后仍然会存在。</p><h1 id="面向对象的语义特征"><a href="#面向对象的语义特征" class="headerlink" title="面向对象的语义特征"></a>面向对象的语义特征</h1><h2 id="从类型角度"><a href="#从类型角度" class="headerlink" title="从类型角度"></a>从类型角度</h2><p>类型处理是语义分析时的重要工作。现代计算机语言可以用自定义的类来声明变量，这是一个巨大的进步。因为早期的计算机语言只支持一些基础的数据类型，比如各种长短不一的整型和浮点型，像字符串这种我们编程时离不开的类型，往往是在基础数据类型上封装和抽象出来的。所以，我们要扩展语言的类型机制，让程序员可以创建自己的类型。</p><h2 id="从作用域角度"><a href="#从作用域角度" class="headerlink" title="从作用域角度"></a>从作用域角度</h2><p>首先是类的可见性。作为一种类型，它通常在整个程序的范围内都是可见的，可以用它声明变量。当然，一些像 Java 的语言，也能限制某些类型的使用范围，比如只能在某个命名空间内，或者在某个类内部。</p><p>对象的成员的作用域是怎样的呢？我们知道，对象的属性（“属性”这里指的是类的成员变量）可以在整个对象内部访问，无论在哪个位置声明。也就是说，对象属性的作用域是整个对象的内部，方法也是一样。这跟函数和块中的本地变量不一样，它们对声明顺序有要求，像 C 和 Java 这样的语言，在使用变量之前必须声明它。</p><h2 id="从生存期的角度"><a href="#从生存期的角度" class="headerlink" title="从生存期的角度"></a>从生存期的角度</h2><p>对象的成员变量的生存期，一般跟对象的生存期是一样的。在创建对象的时候，就对所有成员变量做初始化，在销毁对象的时候，所有成员变量也随着一起销毁。当然，如果某个成员引用了从堆中申请的内存，这些内存需要手动释放，或者由垃圾收集机制释放。</p><p>但还有一些成员，不是与对象绑定的，而是与类型绑定的，比如 Java 中的静态成员。静态成员跟普通成员的区别，就是作用域和生存期不同，它的作用域是类型的所有对象实例，被所有实例共享。生存期是在任何一个对象实例创建之前就存在，在最后一个对象销毁之前不会消失。</p><h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><p>想实现闭包，有两个前提：</p><ul><li><p>函数要变成一等公民。也就是要能把函数像普通数值一样赋值给变量，可以作为参数传递给其他函数，可以作为函数的返回值。</p></li><li><p>要让内层函数一直访问它环境中的变量，不管外层函数退出与否。</p></li></ul><p>其实，只要函数能作为值传来传去，就一定会产生作用域不匹配的情况，这样的内在矛盾是语言设计时就决定了的。闭包是为了让函数能够在这种情况下继续运行所提供的一个方案。</p><h2 id="静态作用域（Static-Scope）"><a href="#静态作用域（Static-Scope）" class="headerlink" title="静态作用域（Static Scope）"></a>静态作用域（Static Scope）</h2><p>如果一门语言的作用域是静态作用域，那么符号之间的引用关系能够根据程序代码在编译时就确定清楚，在运行时不会变。某个函数是在哪声明的，就具有它所在位置的作用域。它能够访问哪些变量，那么就跟这些变量绑定了，在运行时就一直能访问这些变量。</p><blockquote><p>动态作用域（Dynamic Scope）就是变量引用跟变量声明不是在编译时就绑定死了的。在运行时，它是在运行环境中动态地找一个相同名称的变量。在 macOS 或 Linux 中用的 bash 脚本语言，就是动态作用域的。</p></blockquote><p>静态作用域可以由程序代码决定，在编译时就能完全确定，所以又叫做词法作用域（Lexcical Scope）。</p><p>不过这个词法跟词法分析时说的词法不大一样。这里，跟 Lexical 相对应的词汇可以认为是 Runtime，一个是编写时，一个是运行时。</p><p>用静态作用域的概念描述一下闭包：因为我们的语言是静态作用域的，它能够访问的变量，需要一直都能访问，为此，需要把某些变量的生存期延长。</p><p>当然，我们学习使用的大多数语言都是采用静态作用域的（所以我们下面的思路也是基于静态作用域）。</p><h2 id="实现闭包思路"><a href="#实现闭包思路" class="headerlink" title="实现闭包思路"></a>实现闭包思路</h2><p>闭包的内在矛盾是运行时的环境和定义时的作用域之间的矛盾。那么我们把内部环境中需要的变量，打包交给闭包函数，它就可以随时访问这些变量了。</p><p>实现了闭包的机制，函数也变成了一等公民，就是在一定程度上支持了函数式编程（functional programming）。</p><p>函数式编程的一个典型特点就是高阶函数（High-order function）功能，高阶函数是这样一种函数，它能够接受其他函数作为自己的参数。</p><h2 id="闭包小结"><a href="#闭包小结" class="headerlink" title="闭包小结"></a>闭包小结</h2><p>闭包就是把函数在静态作用域中所访问的变量的生存期拉长，形成一份可以由这个函数单独访问的数据。正因为这些数据只能被闭包函数访问，所以也就具备了对信息进行封装、隐藏内部细节的特性。</p><p>“封装，把数据和对数据的操作封在一起”，这是相当面向对象的理解，所以，一个闭包可以看做是一个对象。反过来看，一个对象是不是也可以看做一个闭包，对象的属性，也可以看做被方法所独占的环境变量，其生存期也必须保证能够被方法一直正常的访问。</p><h1 id="类型系统"><a href="#类型系统" class="headerlink" title="类型系统"></a>类型系统</h1><p>在做语法分析时我们可以得到一棵语法树，而基于这棵树能做什么，是语义的事情。比如，+ 号的含义是让两个数值相加，并且通常还能进行缺省的类型转换。所以，如果要区分不同语言的差异，不能光看语言的语法。比如 Java 语言和 JavaScript 在代码块的语法上是一样的，都是用花括号，但在语义上是不同的，一个有块作用域，一个没有。</p><p>相比词法和语法的设计与处理，语义设计和分析要复杂很多。</p><p>这一部分的重点是类型系统。</p><p>围绕类型系统产生过一些争论，有的程序员会拥护动态类型语言，有的会觉得静态类型语言好。要想探究这个问题，我们需要对类型系统有个清晰的了解，最直接的方式，就是建立一个完善的类型系统。</p><p>其实，类型系统是一门语言所有的类型的集合，操作这些类型的规则，以及类型之间怎么相互作用的（比如一个类型能否转换成另一个类型）。如果要建立一个完善的类型系统，形成对类型系统比较完整的认知，需要从两个方面出发：</p><ul><li><p>根据领域的需求，设计自己的类型系统的特征。</p></li><li><p>在编译器中支持类型检查、类型推导和类型转换。</p></li></ul><h2 id="设计类型系统的特征"><a href="#设计类型系统的特征" class="headerlink" title="设计类型系统的特征"></a>设计类型系统的特征</h2><p>事实上，在机器代码这个层面，其实是分不出什么数据类型的。在机器指令眼里，那就是 0101，它并不对类型做任何要求，不需要知道哪儿是一个整数，哪儿代表着一个字符，哪儿又是内存地址。你让它做什么操作都可以，即使这个操作没有意义，比如把一个指针值跟一个字符相加。</p><p>那么高级语言为什么要增加类型这种机制呢？</p><p>对类型做定义很难，但大家公认的有一个说法：类型是针对一组数值，以及在这组数值之上的一组操作。比如，对于数字类型，你可以对它进行加减乘除算术运算，对于字符串就不行。</p><p>所以，类型是高级语言赋予的一种语义，有了类型这种机制，就相当于定了规矩，可以检查施加在数据上的操作是否合法。因此类型系统最大的好处，就是可以通过类型检查降低计算出错的概率。所以，现代计算机语言都会精心设计一个类型系统，而不是像汇编语言那样完全不区分类型。</p><p>不过，类型系统的设计有很多需要取舍和权衡的方面，比如：</p><ul><li><p>面向对象的拥护者希望所有的类型都是对象，而重视数据计算性能的人认为应该支持非对象化的基础数据类型；</p></li><li><p>你想把字符串作为原生数据类型，还是像 Java 那样只是一个普通的类？</p></li><li><p>是静态类型语言好还是动态类型语言好？</p></li><li><p>…</p></li></ul><p>虽然类型系统的设计有很多需要取舍和权衡的方面，但它最需要考虑的是，是否符合这门语言想解决的问题，我们用静态类型语言和动态类型语言分析一下。</p><p>根据类型检查是在编译期还是在运行期进行的，我们可以把计算机语言分为两类：</p><ul><li><p>静态类型语言（全部或者几乎全部的类型检查是在编译期进行的）。</p></li><li><p>动态类型语言（类型的检查是在运行期进行的）。</p></li></ul><p>静态类型语言好处：因为编译期做了类型检查，所以程序错误较少，运行期不用再检查类型，性能更高，在编译时就对类型做很多处理，包括检查类型是否匹配，以及进行缺省的类型转换，大大降低了程序出错的可能性，还能让程序运行效率更高，因为不需要在运行时再去做类型检查和转换。</p><p>动态类型语言好处：不要一遍遍的编译，方便进行快速开发。</p><p>客观地讲，这些说法都有道理。目前的趋势是，某些动态类型语言在想办法增加一些机制，在编译期就能做类型检查，比如用 TypeScript 代替 JavaScript 编写程序，做完检查后再输出成 JavaScript。而某些静态语言呢，却又发明出一些办法，部分地绕过类型检查，从而提供动态类型语言的灵活性。</p><p>再延伸一下，跟静态类型和动态类型概念相关联的，还有强类型和弱类型。强类型语言中，变量的类型一旦声明就不能改变，弱类型语言中，变量类型在运行期时可以改变。二者的本质区别是，强类型语言不允许违法操作，因为能够被检查出来，弱类型语言则从机制上就无法禁止违法操作，所以是不安全的。比如你写了一个表达式 a*b。如果 a 和 b 这两个变量是数值，这个操作就没有问题，但如果 a 或 b 不是数值，那就没有意义了，弱类型语言可能就检查不出这类问题。</p><p>也就是，静态类型和动态类型说的是什么时候检查的问题，强类型和弱类型说的是就算检查，也检查不出来，或者没法检查的问题。</p><h2 id="类型检查、类型推导和类型转换"><a href="#类型检查、类型推导和类型转换" class="headerlink" title="类型检查、类型推导和类型转换"></a>类型检查、类型推导和类型转换</h2><p>举个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = b + 10</span><br></pre></td></tr></table></figure></p><ul><li><p>如果 b 是一个浮点型，b+10 的结果也是浮点型。如果 b 是字符串型的，有些语言也是允许执行 + 号运算的，实际的结果是字符串的连接。这个分析过程，就是类型推导（Type Inference）。</p></li><li><p>当右边的值计算完，赋值给 a 的时候，要检查左右两边的类型是否匹配。这个过程，就是类型检查（Type Checking）。</p></li><li><p>如果 a 的类型是浮点型，而右边传过来的是整型，那么一般就要进行缺省的类型转换（Type Conversion）。</p></li></ul><h1 id="引用的消解"><a href="#引用的消解" class="headerlink" title="引用的消解"></a>引用的消解</h1><p>在程序里使用变量、函数、类等符号时，我们需要知道它们指的是谁，要能对应到定义它们的地方。这个过程，可以叫引用消解。</p><p>在集成开发环境中，当我们点击一个变量、函数或类，可以跳到定义它的地方。另一方面，当我们重构一个变量名称、方法名称或类名称的时候，所有引用它的地方都会同步修改。这是因为 IDE 分析了符号之间的交叉引用关系。</p><h1 id="左值和右值"><a href="#左值和右值" class="headerlink" title="左值和右值"></a>左值和右值</h1><p>举个例子，对下面变量a取值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = 3;</span><br></pre></td></tr></table></figure><p>假设 a 变量原来的值是 4，如果还是把它的值取出来，那么成了 3=4，这就变得没有意义了。所以，不能把 a 的值取出来，而应该取出 a 的地址，或者说 a 的引用，然后用赋值操作把 3 这个值写到 a 的内存地址。这时，我们说取出来的是 a 的左值（L-value）。</p><p>左值最早是在 C 语言中提出的，通常出现在表达式的左边，如赋值语句的左边。左值取的是变量的地址（或者说变量的引用），获得地址以后，我们就可以把新值写进去了。</p><p>与左值相对应的就是右值（R-value），右值就是我们通常所说的值，不是地址。</p><h1 id="从类型体系的角度理解继承和多态"><a href="#从类型体系的角度理解继承和多态" class="headerlink" title="从类型体系的角度理解继承和多态"></a>从类型体系的角度理解继承和多态</h1><p>面向对象的另外两个重要特征：继承和多态</p><p>继承的意思是一个类的子类，自动具备了父类的属性和方法，除非被父类声明为私有的。</p><p>多态的意思是同一个类的不同子类，在调用同一个方法时会执行不同的动作。</p><h2 id="对继承和多态做语义分析："><a href="#对继承和多态做语义分析：" class="headerlink" title="对继承和多态做语义分析："></a>对继承和多态做语义分析：</h2><p>首先，从类型处理的角度出发，我们要识别出新的类型。之后，就可以用它们声明变量了。</p><p>第二，从作用域的角度来看，一个类的属性（或者说成员变量），是可以规定能否被子类访问的。以 Java 为例，除了声明为 private 的属性以外，其他属性在子类中都是可见的。所以父类的属性的作用域，可以说是以树状的形式覆盖到了各级子类。</p><p>第三，要对变量和函数做类型的引用消解。</p><p>但是对于强类型语言来说，编译期无法知道变量的真实类型，可能只知道它的父类型，这样就不能做正确的引用的消解，只能到运行期再解决这个问题。</p><p>在运行期，我们能知道变量具体指向的是那个对象，对象里是保存了真实类型信息，在调用类的属性和方法时，我们可以根据运行时获得的，确定的类型信息进行动态绑定。</p><p>比如，逐级查找某个方法的实现，如果本级和父类都有这个方法，那么本级的就会覆盖掉父类的，这样就实现了多态。</p><p>如果当前类里面没有实现这个方法，它可以直接复用某一级的父类中的实现，这实际上就是继承机制在运行期的原理。</p><h2 id="继承情况下对象的实例化"><a href="#继承情况下对象的实例化" class="headerlink" title="继承情况下对象的实例化"></a>继承情况下对象的实例化</h2><p>在存在继承关系的情况下，创建对象时，不仅要初始化自己这一级的属性变量，还要把各级父类的属性变量也都初始化。</p><p>在逐级初始化的过程中，我们要先执行缺省的成员变量初始化，也就是变量声明时所带的初始化部分，然后调用这一级的构造方法。如果不显式指定哪个构造方法，就会执行不带参数的构造方法。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过上面这些介绍，基本可以看出来：语义分析的本质，就是针对上下文相关的情况做处理。</p><p>囫囵吞枣，大概学习了一遍，哎，复杂程度指数级上涨，难受QAQ</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;学习了&lt;em&gt;词法分析(Lexical Analysis)&lt;/em&gt;和&lt;em&gt;语法分析(Syntactic Analysis, or Par
      
    
    </summary>
    
    
      <category term="编译原理" scheme="https://nijiehaha.github.io/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="编译原理" scheme="https://nijiehaha.github.io/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>语法分析</title>
    <link href="https://nijiehaha.github.io/2019/12/03/%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/"/>
    <id>https://nijiehaha.github.io/2019/12/03/%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/</id>
    <published>2019-12-03T05:30:56.000Z</published>
    <updated>2019-12-03T08:16:59.994Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>学习了<em>词法分析(Lexical Analysis)</em>，并且“装模作样”的实现了大概的词法分析工程，仅仅为了学习而已，接下来接下来就是<em>语法分析(Syntactic Analysis, or Parsing)</em>了。</p><h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><blockquote><p>语法分析是在词法分析的基础上识别出程序的语法结构。这个结构是一个树状结构，是计算机容易理解和执行的.</p></blockquote><p>以自然语言为例。自然语言有定义良好的语法结构，比如，“我喜欢又聪明又勇敢的你”这个句子包含了“主、谓、宾”三个部分。主语是“我”，谓语是“喜欢”，宾语部分是“又聪明又勇敢的你”。其中宾语部分又可以拆成两部分，“又聪明又勇敢”是定语部分，用来修饰“你”。定语部分又可以分成“聪明”和“勇敢”两个最小的单位.</p><p>这样拆下来，会构造一棵树，里面的每个子树都有一定的结构，而这个结构要符合语法。比如，汉语是用“主谓宾”的结构，日语是用“主宾谓”的结构。这时，我们说汉语和日语的语法规则是不同的。</p><p>程序也有定义良好的语法结构，它的语法分析过程，就是构造这么一棵树。一个程序就是一棵树，这棵树叫做<em>抽象语法树（Abstract Syntax Tree，AST）</em>。树的每个节点（子树）是一个语法单元，这个单元的构成规则就叫“语法”。每个节点还可以有下级节点。</p><p><a href="https://www.stephenw.cc/2018/01/08/clang-ast/" target="_blank" rel="noopener">了解 Clang AST</a></p><p>所以，语法分析的结果就是生成AST。</p><h1 id="生成ATS"><a href="#生成ATS" class="headerlink" title="生成ATS"></a>生成ATS</h1><p>如果我们要语法分析</p><ul><li>int age = 45</li></ul><p>那么这个过程可以简单这样来概括：</p><blockquote><p>解析变量声明语句时，我先看第一个 Token 是不是 int。如果是，那我创建一个 AST 节点，记下 int 后面的变量名称，然后再看后面是不是跟了初始化部分，也就是等号加一个表达式。我们检查一下有没有等号，有的话，接着再匹配一个表达式。</p></blockquote><p>通常会对产生式的每个部分建立一个子节点，比如变量声明语句会建立四个子节点，分别是 int 关键字、标识符、等号和表达式。</p><p>我们把解析变量声明语句和表达式的算法分别写成函数。在语法分析的时候，调用这些函数跟后面的 Token 串做模式匹配。匹配上了，就返回一个 AST 节点，否则就返回 null。如果中间发现跟语法规则不符，就报编译错误。</p><p>在这个过程中，上级文法嵌套下级文法，上级的算法调用下级的算法。表现在生成 AST 中，上级算法生成上级节点，下级算法生成下级节点。</p><p>生成的ATS大概是这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Programm Calculator    </span><br><span class="line">    IntDeclaration age        </span><br><span class="line">        AssignmentExp =            </span><br><span class="line">            IntLiteral 45</span><br></pre></td></tr></table></figure></p><p>当然这些都还在正则表达式的文法规则之内，没有超出词法分析时使用的文法。</p><p>我们解析算术表达式的时候，会遇到更复杂的情况，这时，正则文法不够用，我们必须用上下文无关文法来表达。</p><p>算术表达式要包含加法和乘法两种运算（简单起见，我们把减法与加法等同看待，把除法也跟乘法等同看待），加法和乘法运算有不同的优先级。我们的规则要能匹配各种可能的算术表达式：</p><ul><li><p>2+3*5</p></li><li><p>2*3+5</p></li><li><p>2*3</p></li><li><p>….</p></li></ul><p>思考一番之后，我们可以把规则分成两级：第一级是加法规则，第二级是乘法规则。把乘法规则作为加法规则的子规则，这样在解析形成 AST 时，乘法节点就一定是加法节点的子节点，从而被优先计算。</p><p>这种文法已经没有办法改写成正则文法了，它比正则文法的表达能力更强，叫做“上下文无关文法”。正则文法是上下文无关文法的一个子集。它们的区别呢，就是上下文无关文法允许递归调用，而正则文法不允许。</p><p>那有没有上下文相关的情况需要处理呢？也是有的，但那不是语法分析阶段负责的，而是放在语义分析阶段来处理的。</p><h1 id="实现表达式求值"><a href="#实现表达式求值" class="headerlink" title="实现表达式求值"></a>实现表达式求值</h1><p>其实，要实现一个表达式计算，需要基于 AST 做求值运算，也就是对这棵树做深度优先的遍历。</p><p>深度优先的遍历也是一个递归算法。以“2 + 3 * 5”的 AST 为例看一下：</p><ul><li><p>对表达式的求值，等价于对 AST 根节点求值</p></li><li><p>首先求左边子节点，算出是 2。</p></li><li><p>接着对右边子节点求值，这时候需要递归计算下一层。计算完了以后，返回是 15（3*5）。</p></li><li><p>把左右节点相加，计算出根节点的值 17。</p></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>虽然我的目标是能通过这些学习写一个简单能用的解释器，起码可以看作一个玩具，但是，说实话，我有些地方，还不是很理解，只能说大概了解这个过程，所以要是写的话，也只能写个连玩具都算不上的东西，这很无聊，也不是我的本意，所以，还是先囫囵吞枣的学习一遍吧QAQ</p><p>为自己的菜而感到惭愧！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;学习了&lt;em&gt;词法分析(Lexical Analysis)&lt;/em&gt;，并且“装模作样”的实现了大概的词法分析工程，仅仅为了学习而已，接下来接
      
    
    </summary>
    
    
      <category term="编译原理" scheme="https://nijiehaha.github.io/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="编译原理" scheme="https://nijiehaha.github.io/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>手工打造词法分析器</title>
    <link href="https://nijiehaha.github.io/2019/12/02/%E6%89%8B%E5%B7%A5%E6%89%93%E9%80%A0%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8/"/>
    <id>https://nijiehaha.github.io/2019/12/02/%E6%89%8B%E5%B7%A5%E6%89%93%E9%80%A0%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8/</id>
    <published>2019-12-02T06:28:42.000Z</published>
    <updated>2019-12-03T08:42:04.946Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>准备努努力啃一啃编译原理，目标就是能啃多少，啃多少，加油！</p><h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><p>词法分析的工作就是将一个个长长的字符串识别出一个个的单词，这些单词被称为<code>Token</code>, 并且词法分析的工作是一边读取，一边识别字符串的，不是把字符串都读到内存再识别，这跟我们在人类世界听别人说话很类似，一边听，一边提取信息。</p><p>问题来了，如何把一长串的字符，断成一个个的<code>Token</code>呢？如何分割呢？</p><h1 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h1><p>首先拿一个简单的例子来实现，比如：</p><ul><li>age &gt;= 45</li></ul><p>这是一个简单的关系表达式，我们可以用自己熟悉的语言来解析这个表达式，我使用的是<code>swift</code>。大概这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">/// 有限自动机</span><br><span class="line">enum NJDFAState &#123;</span><br><span class="line">    /// 初始化</span><br><span class="line">    case initial</span><br><span class="line">    /// 字母</span><br><span class="line">    case alpha</span><br><span class="line">    /// 大于</span><br><span class="line">    case greaterThan</span><br><span class="line">    /// 大于等于</span><br><span class="line">    case graterEqual</span><br><span class="line">    /// 数字</span><br><span class="line">    case digit</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct NJToken &#123;</span><br><span class="line">    </span><br><span class="line">    var type: NJTokenType?</span><br><span class="line">    var text: String?</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var tokenList:[NJToken] = []</span><br><span class="line">var currentTokenText:[Character] = []</span><br><span class="line">var currentToken:NJToken = NJToken()</span><br><span class="line"></span><br><span class="line">func initToken(ch:Character) -&gt; NJDFAState &#123;</span><br><span class="line">    </span><br><span class="line">    var state = NJDFAState.initial</span><br><span class="line">    </span><br><span class="line">    if isAlpha(ch: ch) &#123;</span><br><span class="line">        </span><br><span class="line">        state = NJDFAState.alpha</span><br><span class="line">        </span><br><span class="line">    &#125; else if ch == &quot;&gt;&quot; &#123;</span><br><span class="line">        </span><br><span class="line">        state = NJDFAState.greaterThan</span><br><span class="line">        </span><br><span class="line">    &#125; else if isDigit(ch: ch) &#123;</span><br><span class="line">        </span><br><span class="line">        state = NJDFAState.digit</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return state</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>词法分析的过程被就是<em>构造好的有限自动机，在不同的状态中迁移，从而解析出Token</em></p><p>所以，上面的的例子<code>age &gt;= 45</code>可以这样解析：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">let script = &quot;age &gt;= 45&quot;</span><br><span class="line">        </span><br><span class="line">let scriptList:[Character] = Array(script)</span><br><span class="line"></span><br><span class="line">var i = 0</span><br><span class="line"></span><br><span class="line">var state = NJDFAState.initial</span><br><span class="line"></span><br><span class="line">while i &lt; scriptList.count &#123;</span><br><span class="line"></span><br><span class="line">    let ch = scriptList[i]</span><br><span class="line"></span><br><span class="line">    switch state &#123;</span><br><span class="line">    case .initial:</span><br><span class="line">        </span><br><span class="line">        state = initToken(ch: ch)</span><br><span class="line">        if !isBlank(ch: ch) &#123;</span><br><span class="line">            currentTokenText.append(ch)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    case .alpha:</span><br><span class="line">        if isAlpha(ch: ch) &#123;</span><br><span class="line">            </span><br><span class="line">            currentTokenText.append(ch)</span><br><span class="line">            </span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            </span><br><span class="line">            state = initToken(ch: ch)</span><br><span class="line">            currentToken.text = String(currentTokenText)</span><br><span class="line">            currentToken.type = .alpha</span><br><span class="line">            tokenList.append(currentToken)</span><br><span class="line">            </span><br><span class="line">            currentTokenText = []</span><br><span class="line">            currentToken = NJToken()</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    case .graterEqual:</span><br><span class="line">        break</span><br><span class="line">        </span><br><span class="line">    case .greaterThan:</span><br><span class="line">        if ch == &quot;=&quot; &#123;</span><br><span class="line">            </span><br><span class="line">            currentTokenText.append(ch)</span><br><span class="line">            </span><br><span class="line">            state = initToken(ch: ch)</span><br><span class="line">            currentToken.text = String(currentTokenText)</span><br><span class="line">            currentToken.type = .graterEqual</span><br><span class="line">            tokenList.append(currentToken)</span><br><span class="line">            </span><br><span class="line">            currentTokenText = []</span><br><span class="line">            currentToken = NJToken()</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    case .digit:</span><br><span class="line">        if isDigit(ch: ch) &#123;</span><br><span class="line">            </span><br><span class="line">            currentTokenText.append(ch)</span><br><span class="line">            </span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            </span><br><span class="line">            state = initToken(ch: ch)</span><br><span class="line">            currentToken.text = String(currentTokenText)</span><br><span class="line">            currentToken.type = .digit</span><br><span class="line">            tokenList.append(currentToken)</span><br><span class="line">            </span><br><span class="line">            currentTokenText = []</span><br><span class="line">            currentToken = NJToken()</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    i += 1</span><br><span class="line"></span><br><span class="line">    if i == scriptList.count &#123;</span><br><span class="line">        </span><br><span class="line">        state = initToken(ch: ch)</span><br><span class="line">        currentToken.text = String(currentTokenText)</span><br><span class="line">        currentToken.type = .digit</span><br><span class="line">        tokenList.append(currentToken)</span><br><span class="line">        </span><br><span class="line">        currentTokenText = []</span><br><span class="line">        currentToken = NJToken()</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print(tokenList)</span><br></pre></td></tr></table></figure></p><p>结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[ComTest.NJToken(</span><br><span class="line">    type: Optional(ComTest.NJTokenType.alpha), </span><br><span class="line">    text: Optional(&quot;age&quot;)), </span><br><span class="line">ComTest.NJToken(</span><br><span class="line">    type: Optional(ComTest.NJTokenType.graterEqual), </span><br><span class="line">    text: Optional(&quot;&gt;=&quot;)), </span><br><span class="line">ComTest.NJToken(</span><br><span class="line">    type: Optional(ComTest.NJTokenType.digit), </span><br><span class="line">    text: Optional(&quot;45&quot;))]</span><br></pre></td></tr></table></figure></p><p>当然，这段代码还有很多值得优化的地方，为了实现思路，很多地方写的相当硬核。</p><p>不过，这还没完成，接下来才是重头戏。</p><h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><p>大家可能发现了，上面的swift代码其实很不严谨，相当硬核，而想要更严谨，<em>正则表达式</em>可以用来解决这个问题。</p><p><a href="https://deerchao.cn/tutorials/regex/regex.htm" target="_blank" rel="noopener">正则表达式</a></p><p>我们来解析<code>int age = 40</code>（此处不是按照swift语法来做的，只是一个简单的例子而已），这个语句中能解析出来的词法是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Int: &apos;int&apos;</span><br><span class="line">id: [a-zA-Z_]([a-zA-Z_]|[0-9]*)</span><br><span class="line">Assignment: &apos;=&apos;</span><br></pre></td></tr></table></figure></p><p>这里，又出现了一个问题，<code>int</code> 这个关键字，和<code>id</code>标识符很容易冲突，都是字母开头，后面跟着其他字母。</p><p>当然，关键字的优先级肯定是要高于标识符的，一般的语言也不允许用关键字做标识符。</p><p>所以，在词法分析器中，我们应该区分关键字和标识符。</p><p>具体思路就是：</p><blockquote><p>当第一个字符是 i 的时候，我们让它进入一个特殊的状态。接下来，如果它遇到 n 和 t，就进入状态 4。但这还没有结束，如果后续的字符还有其他的字母和数字，它又变成了普通的标识符。比如，我们可以声明一个 intA（int 和 A 是连着的）这样的变量，而不会跟 int 关键字冲突。</p></blockquote><p>了解了思路，接下来就是用自己熟悉的语言来实现了，这里就不贴代码了。</p><p>顺便说一下swift中的正则表达式用<code>NSRegularExpression</code>来处理。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>手写一个词法分析器，我写的这个，其实就是个简单的展示demo，还有很多问题，优化什么，我真是能力有限，以后再说。</p><p>词法分析器的过程大概就是这样：</p><blockquote><p>要实现一个词法分析器，首先需要写出每个词法的正则表达式，并画出有限自动机，之后，用代码表示这种状态迁移过程</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;准备努努力啃一啃编译原理，目标就是能啃多少，啃多少，加油！&lt;/p&gt;
&lt;h1 id=&quot;开始&quot;&gt;&lt;a href=&quot;#开始&quot; class=&quot;hea
      
    
    </summary>
    
    
      <category term="编译原理" scheme="https://nijiehaha.github.io/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="编译原理" scheme="https://nijiehaha.github.io/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>坑爹的Swift REPL</title>
    <link href="https://nijiehaha.github.io/2019/11/29/%E5%9D%91%E7%88%B9%E7%9A%84Swift-REPL/"/>
    <id>https://nijiehaha.github.io/2019/11/29/%E5%9D%91%E7%88%B9%E7%9A%84Swift-REPL/</id>
    <published>2019-11-29T01:27:56.000Z</published>
    <updated>2019-12-02T02:36:35.998Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>昨天稍微探索了LLDB如何调试C，随后心血来潮想要再探索一下swift如何利用LLDB来调试，不过坑爹的事情发生了。</p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>首先是swift和swiftc，如果你愿意的话，在Bash中输入<code>-h</code>展示的说明都是Swift compiler，这我一瞬间有点糊涂了。</p><p>赶紧利用万能的搜索引擎，去搜索了一下, 了解了一下, 结果如下，感兴趣的可以看下：</p><ul><li><p><a href="https://stackoverflow.com/questions/57777091/whats-the-difference-between-swift-and-swiftc" target="_blank" rel="noopener">swift和swiftc的区别</a></p></li><li><p><a href="https://swifter.tips/swift-cli/" target="_blank" rel="noopener">喵神的说明</a></p></li></ul><p>简单来说：swift是一个REPL环境，使得使用swift就像使用脚本语言一样，但实际上，还是需要编译后再运行的，所以只是表现的很像”即时的解释执行”，使用起来限制也很多。swiftc就是正宗的swift的编译器前端了。<br>swift的编译架构 是 <code>Swift / LLVM</code></p><h1 id="开始坑爹之旅"><a href="#开始坑爹之旅" class="headerlink" title="开始坑爹之旅"></a>开始坑爹之旅</h1><p>好吧，了解了这些之后，我对swiftc就失去了探索的兴趣，因为我感觉这个应该和clang使用起来差不多，事实上也确实是这样。<br>所以，我开始探索，如何再swift REPL中使用LLDB调试</p><p>因为在<code>swift -h</code>中，我是能看到这段说明的：</p><blockquote><p>-g </p></blockquote><blockquote><p>Emit debug info. This is the preferred setting for debugging with LLDB.</p></blockquote><p>这让我坚信，即使在REPL环境，我也是能使用LLDB调试的。</p><p>但是万万没想到</p><p><a href="https://swift.org/lldb/" target="_blank" rel="noopener">苹果的官方文档</a>的使用例子，我居然不能使用。</p><p>仔细看了说明后，发现了这句话：</p><blockquote><p>However, because of this tight integration, developers must use a matched pair of compiler and debugger built using the same sources. Debugging using any other version of LLDB can lead to unpredictable results.</p></blockquote><p>看上去，可能是版本不匹配？</p><p>然后在swift的官网，发现一个<a href="https://github.com/apple/swift-lldb" target="_blank" rel="noopener">swift-lldb</a>项目。</p><p>这里给了你如何给你本机的swift编译一个匹配的LLDB版本。</p><p>这时候，我还不死心，我查看了一下LLDB的版本，以及支持的swift的版本，可能因为我没更新xcode，我的本机swift版本是5.0.1，而lldb的目标swift版本是5.0, 我也不知道这是不是问题所在，反正，我的swift REPL还没办法使用lldb来加断点什么的，我很郁闷QAQ</p><p>但是使用swiftc的话，一切都是那么的美好！</p><p>好吧，我的天呐！</p><p>我爱swiftc！</p><h1 id="加餐"><a href="#加餐" class="headerlink" title="加餐"></a>加餐</h1><p><a href="https://github.com/ming1016/study/wiki/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90-iOS-%E7%BC%96%E8%AF%91-Clang---LLVM" target="_blank" rel="noopener">深入剖析 iOS 编译 Clang LLVM</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;昨天稍微探索了LLDB如何调试C，随后心血来潮想要再探索一下swift如何利用LLDB来调试，不过坑爹的事情发生了。&lt;/p&gt;
&lt;h1 id=
      
    
    </summary>
    
    
      <category term="LLDB" scheme="https://nijiehaha.github.io/categories/LLDB/"/>
    
    
      <category term="LLDB" scheme="https://nijiehaha.github.io/tags/LLDB/"/>
    
  </entry>
  
  <entry>
    <title>LLDB调试C程序</title>
    <link href="https://nijiehaha.github.io/2019/11/28/LLDB%E8%B0%83%E8%AF%95C%E7%A8%8B%E5%BA%8F/"/>
    <id>https://nijiehaha.github.io/2019/11/28/LLDB%E8%B0%83%E8%AF%95C%E7%A8%8B%E5%BA%8F/</id>
    <published>2019-11-28T07:26:54.000Z</published>
    <updated>2019-12-02T02:39:16.066Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><a href="https://zh.wikipedia.org/wiki/Clang" target="_blank" rel="noopener">Clang</a>是一个C、C++、Objective-C和Objective-C++编程语言的编译器前端。它采用了LLVM作为其后端。</p><p><a href="https://lldb.llvm.org/" target="_blank" rel="noopener">LLDB</a>是一个支持C, Objective-C and C++的调试器，内置于xcode。</p><h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><p>c测试代码, 文件名mylldb.c<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    </span><br><span class="line">    int i = 0;</span><br><span class="line">    </span><br><span class="line">    printf(&quot;hello lldb\n&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="clang生成输出文件"><a href="#clang生成输出文件" class="headerlink" title="clang生成输出文件"></a>clang生成输出文件</h1><p>使用<code>-g</code>和<code>-o</code>生成调试信息和输出文件，我们这里分别是<code>mylldb.DSYM</code>和<code>mylldb</code>。</p><h1 id="进入LLDB"><a href="#进入LLDB" class="headerlink" title="进入LLDB"></a>进入LLDB</h1><p>使用<code>-f</code>载入<code>mylldb</code></p><p>使用<code>breakpoint set --file</code>设置断点</p><p>使用<code>run</code>启动程序</p><p>接下来程序会停在断点处，<code>thread</code>, <code>print</code>, <code>expression</code>等等一系列调试命令就都可以使用了</p><p><a href="https://developer.apple.com/library/mac/documentation/IDEs/Conceptual/gdb_to_lldb_transition_guide/document/lldb-command-examples.html#//apple_ref/doc/uid/TP40012917-CH3-SW5" target="_blank" rel="noopener">LLDB命令</a></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://southpeak.github.io/2015/01/25/tool-lldb/" target="_blank" rel="noopener">LLDB调试器使用简介</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/Clang&quot; target=&quot;_blank&quot; rel=&quot;noo
      
    
    </summary>
    
    
      <category term="LLDB" scheme="https://nijiehaha.github.io/categories/LLDB/"/>
    
    
      <category term="LLDB" scheme="https://nijiehaha.github.io/tags/LLDB/"/>
    
  </entry>
  
  <entry>
    <title>关于遮罩(mask)</title>
    <link href="https://nijiehaha.github.io/2019/11/26/%E5%85%B3%E4%BA%8E%E9%81%AE%E7%BD%A9-mask/"/>
    <id>https://nijiehaha.github.io/2019/11/26/%E5%85%B3%E4%BA%8E%E9%81%AE%E7%BD%A9-mask/</id>
    <published>2019-11-26T05:20:32.000Z</published>
    <updated>2019-12-02T02:36:10.267Z</updated>
    
    <content type="html"><![CDATA[<p>遮罩(Mask)，就是一幅只有单通道，肉眼看上去只有黑白，和黑白之间颜色的图片，通过可透过光和不可透过光，来遮挡下面的图片，达到不同的效果，可以理解为四通道图片中的alpha通道，所以也可以叫alpha图。</p><p>遮罩图中，直观肉眼看上去，0代表黑色，255代表白色。</p><p>遮罩图和被遮罩图融合一般情况都是作为前景图，在这种情况下：</p><blockquote><p>遮罩图在和被遮罩图融合的时候，0代表透明度为0，也就是完全透明，1代表不透明，肉眼看上去，就是白色部分透明，黑色的部分不透明。融合的话，可以使用<a href="https://developer.apple.com/documentation/coregraphics/1455939-cgbitmapcontextcreate?language=objc" target="_blank" rel="noopener">CGBitmapContextCreate</a>拿到遮罩图和被遮罩图的像素数组，自己组合计算，也可以利用<a href="https://developer.apple.com/documentation/coregraphics/1456337-cgimagecreatewithmask" target="_blank" rel="noopener">CGImageCreateWithMask</a>，直接利用系统api帮助你合成。</p></blockquote><p>甚至可以用<code>CGContext</code>来为自己合成，类似这样<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">UIGraphicsBeginImageContextWithOptions(self.size, NO, 0.0f);</span><br><span class="line"></span><br><span class="line">[tintColor setFill];</span><br><span class="line"></span><br><span class="line">CGRect bounds = CGRectMake(0, 0, self.size.width, self.size.height);</span><br><span class="line"></span><br><span class="line">UIRectFill(bounds);</span><br><span class="line"></span><br><span class="line">[self drawInRect:bounds blendMode:blendMode alpha:1.0f];</span><br><span class="line"></span><br><span class="line">if (blendMode != kCGBlendModeDestinationIn) &#123;</span><br><span class="line">    [self drawInRect:bounds blendMode:kCGBlendModeDestinationIn alpha:1.0f];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">UIImage *tintedImage = UIGraphicsGetImageFromCurrentImageContext();</span><br><span class="line"></span><br><span class="line">UIGraphicsEndImageContext();</span><br></pre></td></tr></table></figure></p><p>遮罩图作为背景图来融合另一张图的时候，和作为前景图融合是相反的，也就是黑是透明，白是不透明，这种情况比较少见。</p><p>在iOS中，CALayer，处理<a href="https://developer.apple.com/documentation/quartzcore/calayer/1410861-mask" target="_blank" rel="noopener">mask</a>和<a href="https://developer.apple.com/documentation/quartzcore/calayer/1410773-contents" target="_blank" rel="noopener">contents</a>属性的时候，肉眼直观显示，黑色代表可透过光，白色不可透光。</p><p>所以，<strong>在一张肉眼可见的黑白的alpha单通道图上，透明和不透明，是通过白色和黑色来处理的</strong>，这就为我们的画板增加了想像的空间，也就是说:</p><p><strong>在遮罩图上，没有透明色(clearColor), 只有白，黑，及黑白之间的颜色</strong></p><p>事实上单纯的单通道alpha图，看上去是黑白的，但是我们使用他是为了遮挡和显示被遮罩图的，所以，为了在显示的时候，能够直观的看到效果，<a href="https://developer.apple.com/documentation/coregraphics/1455089-cgimagemaskcreate" target="_blank" rel="noopener">CGImageMaskCreate</a>是一个重要的api, 可以把”看上去黑白”的遮罩图，转为可以在iOS中使用的遮罩图。</p><p>这一块的东西比较绕，所以我写个博客记录一下，便于以后弄晕了，再来看看QAQ</p><p><a href="https://github.com/nijiehaha/testMaskDrawBoard" target="_blank" rel="noopener">测试demo</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;遮罩(Mask)，就是一幅只有单通道，肉眼看上去只有黑白，和黑白之间颜色的图片，通过可透过光和不可透过光，来遮挡下面的图片，达到不同的效果，可以理解为四通道图片中的alpha通道，所以也可以叫alpha图。&lt;/p&gt;
&lt;p&gt;遮罩图中，直观肉眼看上去，0代表黑色，255代表白色
      
    
    </summary>
    
    
      <category term="iOS" scheme="https://nijiehaha.github.io/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://nijiehaha.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>hybrid框架:js异步回调实现</title>
    <link href="https://nijiehaha.github.io/2019/11/15/hybrid%E6%A1%86%E6%9E%B6-js%E5%BC%82%E6%AD%A5%E5%9B%9E%E8%B0%83%E5%AE%9E%E7%8E%B0/"/>
    <id>https://nijiehaha.github.io/2019/11/15/hybrid%E6%A1%86%E6%9E%B6-js%E5%BC%82%E6%AD%A5%E5%9B%9E%E8%B0%83%E5%AE%9E%E7%8E%B0/</id>
    <published>2019-11-15T08:03:49.000Z</published>
    <updated>2020-01-20T03:14:21.358Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近学习了一段时间<code>hybrid</code>，写一点收获，本文主要关注的是<code>js</code>调用原生的时候，异步回调，如何处理，这是实现一个<code>JSBridge</code>的关键。</p><p>下面，我们开始</p><h1 id="js消息体"><a href="#js消息体" class="headerlink" title="js消息体"></a>js消息体</h1><p>代码类似这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var msgBody = &#123;&#125;;</span><br><span class="line">msgBody.handler = &apos;common&apos;;</span><br><span class="line">msgBody.action = &apos;nativeLog&apos;;</span><br><span class="line">msgBody.params = params; //任意json对象，用于传参.</span><br><span class="line">msgBody.callbackId = &apos;&apos;;</span><br><span class="line">msgBody.callbackFunction = &apos;&apos;;</span><br></pre></td></tr></table></figure></p><p><code>callbackId</code>: 对每一次消息需要发起回调都会生成一个唯一ID，用来当回调发生时，找到最初的发起调用的 <code>JS Callback</code></p><p><code>callbackFunction</code>: 客户端主动 <code>Call JS</code> 的唯一函数入口，客户端会用这个字符串来拼接回调注入的 JS 头，一般设计下，每个消息这个值都应该不变，不过也可以灵活处理（本来这个值可以不需要传递，写死在客户端，只要前端客户端约定好，但如果这个值不写死，而由前端可控操作，那么灵活性会更大，不必担心前端大规模修改 <code>Call JS</code> 唯一入口的时候，还得等客户端发版）</p><p>代码大概如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">sendMessage: function (data,callback) &#123;</span><br><span class="line">    if (callback &amp;&amp; typeof (callback) === &apos;function&apos;) &#123;</span><br><span class="line">        var callbackid = this.getNextCallbackID();</span><br><span class="line">        this.msgCallbackMap[callbackid] = callback;</span><br><span class="line">        params.callbackId = callbackid;</span><br><span class="line">        params.callbackFunction = &apos;window.callbackDispatcher&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (this.isIOS) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            window.webkit.messageHandlers.WKJSBridge.postMessage(data);</span><br><span class="line">        &#125;</span><br><span class="line">        catch (error) &#123;</span><br><span class="line">            console.log(&apos;error native message&apos;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (this.isAndroid) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            prompt(JSON.stringify([data]));</span><br><span class="line">        &#125;</span><br><span class="line">        catch (error) &#123;</span><br><span class="line">            console.log(&apos;error native message&apos;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">    </span><br><span class="line">sendHaHaHaMessage(msgBody,function(result)&#123;</span><br><span class="line">console.log(&apos;回调触发&apos;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>可以看到我们着手修改 <code>sendMessage</code> 函数，如果在调用的时候多写了一个<code>callback</code>函数，那么就会认为该次通信需要回调，因此对 <code>callbackId</code> 与 <code>callbackFunction</code> 进行赋值，callbackId 是一个保证每次通信都唯一的一个id值 <code>getNextCallbackID</code> ，大概思路可以是用时间戳+一定程度的随机小数来进行生成，思路不深入展开了。 <code>callbackFunction</code> 这里我们先写 <code>window.callbackDispatcher</code> 。</p><p>这里有一步最最重要的操作就是:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.msgCallbackMap[callbackid] = callback;</span><br></pre></td></tr></table></figure></p><p>会把 JS 业务的回调函数，保存在一个全局可处理的回调字典之中，而 Key 就是这个唯一ID <code>callbackId</code>，这样当 <code>OC</code> 发起回调的时候，你才能找到对应的 <code>JS Function</code></p><h1 id="原生处理（以OC做示例）"><a href="#原生处理（以OC做示例）" class="headerlink" title="原生处理（以OC做示例）"></a>原生处理（以OC做示例）</h1><p>首先是OC的消息类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">typedef void (^JSResponseCallback)(NSDictionary* responseData);</span><br><span class="line"></span><br><span class="line">@interface msgObject : NSObject</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithDictionary:(NSDictionary *)dict;</span><br><span class="line"></span><br><span class="line">@property (nonatomic, copy, readonly) NSString * handler;</span><br><span class="line">@property (nonatomic, copy, readonly) NSString * action;</span><br><span class="line">@property (nonatomic, copy, readonly) NSDictionary * parameters;</span><br><span class="line">@property (nonatomic, copy, readonly) NSString * callbackID;</span><br><span class="line">@property (nonatomic, copy, readonly) NSString  *callbackFunction;</span><br><span class="line"></span><br><span class="line">-(void)setCallback:(JSResponseCallback)callback; //block 作为属性，保存在msgObject的.m文件里</span><br><span class="line"></span><br><span class="line">-(void)callback:(NSDictionary *)result;//在msgObject的.m文件里 调用保存在消息体里的block</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><p>所以我们继续修改 OC 这边收到 JS 消息的函数体，当判断消息体含有回调信息的时候，就会生成用于回调的 OC Block，当OC业务处理完毕，准备回调回传数据的时候使用, 代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">-(void)userContentController:(WKUserContentController *)userContentController didReceiveScriptMessage:(WKScriptMessage *)message&#123;</span><br><span class="line">    NSDictionary *msgBody = message.body;</span><br><span class="line">    if (msgBody) &#123;</span><br><span class="line">        msgObject *msg = [[msgObject alloc]initWithDictionary:msgBody];</span><br><span class="line">        NSDictionary *handlerDic = [self.handlerMap objectForKey:msg.handler];</span><br><span class="line">        HandlerBlock handler = [handlerDic objectForKey:msg.action];</span><br><span class="line">        //处理回调</span><br><span class="line">        if (msg.callbackID &amp;&amp; msg.callbackID.length &gt; 0) &#123;</span><br><span class="line">            //生成OC的回调block，输入参数是，任意字典对象的执行结果</span><br><span class="line">            JSResponseCallback callback = ^(id responseData)&#123;</span><br><span class="line">                //执行OC 主动 Call JS 的编码与通信</span><br><span class="line">                [weakSelf injectMessageFuction:callbackFunction withActionId:callbackId withParams:responseData];</span><br><span class="line">            &#125;;</span><br><span class="line">            [msg setCallback:callback];</span><br><span class="line">        &#125;</span><br><span class="line">        if (handler)&#123;</span><br><span class="line">            handler(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>那业务在注册 OC 消息处理函数的时候，就可以使用这个block 进行回调，大概是这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[self registerHandler:@&quot;common&quot; Action:@&quot;nativeLog&quot; handler:^(msgObject *msg) &#123;</span><br><span class="line">    NSLog(@&quot;webview log : \n%@&quot;,msg)</span><br><span class="line">    NSDictionary *result = @&#123;@&quot;result&quot;:&quot;result&quot;&#125;;</span><br><span class="line">    //回调一个key value均为 result 字符串的字典当做数据</span><br><span class="line">    [msg callback:result];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure></p><p>以上就是大概的思路。</p><p>如果只是需要js和原生通信的话，<code>UIWebView</code>，<code>WKWebView</code>，<code>JavaScriptCore</code>都提供了很多方法，感兴趣的可以去了解一下，嘻嘻嘻QAQ</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://awhisper.github.io/2018/03/06/hybrid-webcontainer/" target="_blank" rel="noopener">从零收拾一个hybrid框架</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近学习了一段时间&lt;code&gt;hybrid&lt;/code&gt;，写一点收获，本文主要关注的是&lt;code&gt;js&lt;/code&gt;调用原生的时候，异步回调
      
    
    </summary>
    
    
      <category term="iOS" scheme="https://nijiehaha.github.io/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://nijiehaha.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>swift上的装饰器(Decorator)</title>
    <link href="https://nijiehaha.github.io/2019/11/15/swift%E4%B8%8A%E7%9A%84%E8%A3%85%E9%A5%B0%E5%99%A8/"/>
    <id>https://nijiehaha.github.io/2019/11/15/swift%E4%B8%8A%E7%9A%84%E8%A3%85%E9%A5%B0%E5%99%A8/</id>
    <published>2019-11-15T00:47:16.000Z</published>
    <updated>2019-12-02T02:40:00.987Z</updated>
    
    <content type="html"><![CDATA[<p>作为一名swift萌新，已经深深爱上了这门语言，也认识到这门语言可没有看上去这么简单，于是总是想折腾一点不一样的东西，目的都是为了更好的理解swift这门语言</p><h1 id="python上的装饰器-Decorator"><a href="#python上的装饰器-Decorator" class="headerlink" title="python上的装饰器(Decorator)"></a>python上的装饰器(Decorator)</h1><p>python上的装饰器很酷，提供了@这个语法糖，当你想为你的函数提供一个新的功能，却不想对原来函数做改变的时候，这个时候装饰器的作用就来了，我们可以用下面的方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">from functools import wraps</span><br><span class="line"> </span><br><span class="line">def log(func):</span><br><span class="line">    @wraps(func)</span><br><span class="line">    def with_logging(*args, **kwargs):</span><br><span class="line">        print(func.__name__ + &quot; was called&quot;)</span><br><span class="line">        return func(*args, **kwargs)</span><br><span class="line">    return with_logging</span><br><span class="line"> </span><br><span class="line">@log</span><br><span class="line">def addition_func(x):</span><br><span class="line">   return x + x</span><br><span class="line"></span><br><span class="line">result = addition_func(4)</span><br></pre></td></tr></table></figure><p>这样就为<code>addition_func</code>方法功能扩展了一个日志打印的功能</p><p>当然，其他语言也有自己的装饰器实现，但是对我来说，比较好理解的就是python的装饰器实现了。</p><p>从上面的代码也能看出来，把原来函数传进去，先执行装饰函数，再返回原来的函数，执行原来的函数。</p><h1 id="swift中的函数和闭包"><a href="#swift中的函数和闭包" class="headerlink" title="swift中的函数和闭包"></a>swift中的函数和闭包</h1><p>首先<code>swift</code>中的函数和闭包，对我来说是等价的，无论是<code>func</code>还是<code>{}</code>，在我的理解下，都是等价的，他们有个函数名称，有一个参数列表，有一个返回值列表，并且他们都是<code>tuple</code>，也就是元组，就算是<code>void</code>，在<code>swift</code>中也是一个空元组<code>()</code>，这是一个很关键的部分。</p><h1 id="泛型编程"><a href="#泛型编程" class="headerlink" title="泛型编程"></a>泛型编程</h1><p>泛型是通过参数化类型来实现在同一份代码上操作多种数据类型。利用“参数化类型”将类型抽象化，从而实现灵活的复用.<br>第一次听说泛型是在C++中，类似像这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Task&lt;T&gt; &#123;</span><br><span class="line">    public T obj;</span><br><span class="line">    public Task(T t)&#123;</span><br><span class="line">        this.obj = t;</span><br><span class="line">    &#125;     </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>直到你实现这个具体类型之前，没人知道它到底是什么，这是我粗浅的理解，swift也提供了这样的能力，大概是这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func goToOnePiece&lt;T&gt;(product: T) &#123;</span><br><span class="line">    return T</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>swift的内置类型，函数，大范围运用了泛型编程，比如数组中的<code>element</code></p><h1 id="开始实现swift中的装饰器"><a href="#开始实现swift中的装饰器" class="headerlink" title="开始实现swift中的装饰器"></a>开始实现swift中的装饰器</h1><p>有了函数和泛型这两个武器，我们开始实现了，首先第一步，给这个装饰器取个名字，叫<code>decorate</code>吧，初始的时候，这个函数应该是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func decorate&lt;T, U&gt;(_ function: @escaping(T) -&gt; U, decoration: @escaping(T, U) -&gt; U) -&gt; (T) -&gt; U &#123;</span><br><span class="line">    return &#123; args in</span><br><span class="line">        decoration(args, function(args))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>function</code>就是原来的函数，<code>decoration</code>就是装饰函数，最终需要返回原来的<code>function</code>, <code>T</code>和<code>U</code>，分别是参数列表和返回值列表，也就是<code>tuple</code></p><p>使用方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let add = decorate(+) &#123; (args, rv) in</span><br><span class="line">    print(&quot;In: \(args)&quot;)</span><br><span class="line">    print(&quot;Out: \(rv)&quot;)</span><br><span class="line">    return rv</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let tuple = (2,4)</span><br><span class="line">add(tuple)</span><br></pre></td></tr></table></figure></p><p>不过这里，我还有点不满足，我想把<code>decorate</code>自定义成一个操作符<code>@</code>，可惜swift中已经有这个高级操作符了，所以，就作罢了，不过我的目的，也基本达到了，嘻嘻嘻，很快乐</p><p>当然，其实这个实现是没什么意义的，只是我个人的突发奇想，除了练习swift以外，确实没啥大用，哈哈，因为本身swift有更好的方式实现装饰器模式，比如用swift的<code>protocol</code>，使用起来更加的优雅</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;作为一名swift萌新，已经深深爱上了这门语言，也认识到这门语言可没有看上去这么简单，于是总是想折腾一点不一样的东西，目的都是为了更好的理解swift这门语言&lt;/p&gt;
&lt;h1 id=&quot;python上的装饰器-Decorator&quot;&gt;&lt;a href=&quot;#python上的装饰器-
      
    
    </summary>
    
    
      <category term="Swift" scheme="https://nijiehaha.github.io/categories/Swift/"/>
    
    
      <category term="Swift" scheme="https://nijiehaha.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>内存管理</title>
    <link href="https://nijiehaha.github.io/2019/06/03/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>https://nijiehaha.github.io/2019/06/03/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</id>
    <published>2019-06-03T02:49:07.000Z</published>
    <updated>2019-12-02T03:06:27.198Z</updated>
    
    <content type="html"><![CDATA[<p>看了andriod和iOS上不同的内存管理机制，写篇文章记录并总结一下，嘻嘻嘻。</p><h1 id="iOS的内存管理"><a href="#iOS的内存管理" class="headerlink" title="iOS的内存管理"></a>iOS的内存管理</h1><p>在日常iOS开发中，监控崩溃是一个很常见的事，但是总有一些崩溃是那么的无厘头，让人摸不着头绪，这种OOM有可能来自iOS的JetSam机制导致的一种“另类”崩溃，我们的日志系统是无法通过信号捕捉到的。</p><blockquote><p><code>JetSam</code> 机制，指的就是操作系统为了控制内存资源过度使用而采用的一种资源管控机制 </p></blockquote><p>不同的系统版本对App运行时占用内存的限制不同，有一种方法就是查看手机中以 <code>JetsamEvent</code>开头的系统日志（<em>设置</em> -&gt; <em>隐私</em> -&gt; <em>分析</em>）。</p><blockquote><p>系统版本的升级也会增加占用的内存，App功能的增多也会要求越来越多的内存</p></blockquote><p>因为移动设备的内存资源有限，当App运行时占用的内存大小超过了限制后，就会被强制杀掉，这也是作为开发者需要重视内存管理的原因。</p><p>苹果公司主要采用的内存管理技术是<code>引用计数方法</code>。</p><p>引用技术可以及时地回收引用计数为0的对象，减少查找次数，但是引用计数会带来循环引用的问题，我们需要通过弱引用，来解决问题。</p><p>另外，在ARC之前，一直是通过MRC这种手写大量内存管理代码的方式来管理内存的，相当麻烦，后来苹果公司开发了ARC技术，由编译器来完成这部分代码，不过依然需要注意循环引用的问题，而且运行时错误往往难以定位，所以写的时候遇到可能导致循环引用的地方，需要多多考虑一下。</p><p>当ARC的内存管理代码交由编译器自动添加之后，某些情况下效率比MRC低一些，所以，在性能敏感的模块，也可以考虑MRC。</p><h1 id="andriod内存管理"><a href="#andriod内存管理" class="headerlink" title="andriod内存管理"></a>andriod内存管理</h1><p>andriod主要有GC（Garbage Collection）的标记清除算法，这种技术可以自动清空<code>堆</code>中不再使用的对象。</p><blockquote><p>在Java中，对象是通过引用使用的，如果没有引用指向该对象，该对象就无法处理和被调用，类似这样的对象称为<code>不可到达(unreachable)</code>，垃圾回收用于释放不可到达的对象所占据的内存</p></blockquote><p>主要的实现思想：遍历栈中所有的对象的引用，再遍历一遍堆中的对象。因为栈中的对象的引用执行完毕就删除，所以我们就可以通过栈中的对象的引用，查找到堆中没有被指向的对象，对这些对象其进行垃圾回收。（<code>标记回收算法(Mark and Sweep GC)</code>）</p><blockquote><p>其他还有<code>复制算法(Copying)</code>, <code>标记-压缩算法 (Mark-Compact)</code>, <code>分代</code></p></blockquote><blockquote><p>如果持有对象的强引用，垃圾回收器是无法在内存中回收这个对象</p></blockquote><p>当然这种机制也是有一些小问题的，比如这个过程需要中断进程中的其他组件，并且可能产生内存碎片，也就是大量的不连续的内存。</p><p>当然似乎这些问题在ART上被解决的还不错～</p><h1 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h1><p>要想深入了解管理内存的方式，我们不仅仅要关注用户态接口层面，比如引用计数算法和循环引用监控技巧，还需要了解管理内存的演进过程。</p><p>在最开始的时候，程序员直接访问物理内存，但是到了多程序多任务同时运行，就出现了很多问题，比如同时运行的总内存必须要小于实际物理内存大小，程序能够直接访问物理内存，也就能直接访问和修改其他程序的数据，运行时的安全也就无法保障，于是<code>虚拟内存（VM）</code>就应运而生。</p><blockquote><p>由于要解决以上问题，聪明的前辈们想到了办法，增加了一个中间层，称为虚拟内存，然后虚拟内存通过映射，再将虚拟地址转化为物理地址</p></blockquote><p>虚拟内存是硬件异常，硬件地址翻译，主存，磁盘文件和内核软件的完美交互，它为每个进程提供了一个大的，一致的和私有的地址空间。</p><p>虚拟内存的能力：</p><ul><li>它将主存看成是一个存储在磁盘上的地址空间的高速缓存，在主存中只保存活动区域，并根据需要在磁盘和主存之间来回传递数据，通过这种方式，高校地使用了主存。</li><li>它为每个进程提供了一致的地址空间，简化了内存管理。</li><li>它保护了每个进程的地址空间不被其他程序破坏。</li></ul><p>因为VM会给每个程序创建一个单独的执行环境，也就是一个独立的虚拟空间，这样每个程序就只能访问子集的地址空间（Address Space），程序与程序间也就被安全地隔离开了。并且操作起来和物理内存一样高效。</p><p>概念上来说，虚拟内存被组织为一个由存放在磁盘上的N个连续的字节大小的单元组成的数组。每字节都有一个唯一的虚拟地址，作为到数组的索引。磁盘上数组的内容被缓存在主存中。和存储器层次结构中其他缓存一样，磁盘上的数据被分割为块，这些块作为磁盘和主存之间的传输单元。VM系统通过将虚拟内存分割为称为<code>虚拟页（Virtual Page, VP）</code>的大小固定的块来处理这个问题。类似地，物理内存被分割为<code>物理页（Physical Page， PP）</code>, 也被称为页帧（page frame）。</p><p> 在任意时刻，虚拟页面的集合都分为三个不相交的子集：</p><ul><li>未分配的</li><li>缓存的</li><li>未缓存的</li></ul><blockquote><p>SRAM缓存表示位于CPU和主存之间的L1，L2和L3高速缓存，用DRAM缓存来表示虚拟内存系统的缓存，它在主存中缓存虚拟页<br>这样操作系统只需要维护一份<code>页表（Page Table）</code>来记录虚拟页和物理页的关系就好了，不需要考虑堆和栈具体会申请多少空间，只需要考虑多少页就好了</p></blockquote><p>虚拟页的前两位是<code>Virtual Page Number</code>, 根据页表，翻译为物理地址<code>Physical Frame Number</code>。</p><p>虚拟页和物理页之间的映射关系，也就是虚拟内存和物理内存的关系，如下图所示：</p><p><img src="/images/内存管理/Vm.jpg" alt="虚拟内存和物理内存关系"></p><p>翻译步骤：</p><ul><li>处理器生成一个虚拟地址，并把它传送给MMU。</li><li>MMU生成PTE地址，并从高速缓存或主存中请求得到</li><li>高速缓存或主存向MMU返回PTE</li><li>MMU构造物理地址，并把它传送给高速缓存或主存</li><li>高速缓存或主存返回所请求的数据字给处理器</li></ul><p>当然虚拟内存的内容很多，简单一篇文章也说不明白，还需要多多去查看资料，去理解～</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;看了andriod和iOS上不同的内存管理机制，写篇文章记录并总结一下，嘻嘻嘻。&lt;/p&gt;
&lt;h1 id=&quot;iOS的内存管理&quot;&gt;&lt;a href=&quot;#iOS的内存管理&quot; class=&quot;headerlink&quot; title=&quot;iOS的内存管理&quot;&gt;&lt;/a&gt;iOS的内存管理&lt;/h1&gt;&lt;
      
    
    </summary>
    
    
      <category term="iOS" scheme="https://nijiehaha.github.io/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://nijiehaha.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>少年探案</title>
    <link href="https://nijiehaha.github.io/2019/05/24/%E5%B0%91%E5%B9%B4%E6%8E%A2%E6%A1%88/"/>
    <id>https://nijiehaha.github.io/2019/05/24/%E5%B0%91%E5%B9%B4%E6%8E%A2%E6%A1%88/</id>
    <published>2019-05-24T05:29:16.000Z</published>
    <updated>2019-12-02T02:37:52.600Z</updated>
    
    <content type="html"><![CDATA[<p>(5年级到6年级的暑假写的，读来还有点害羞，嘻嘻QAQ)</p><p>这个故事的主人公叫皿雄，虽然家境贫寒，但是他并没有自暴自弃，他热爱读书，尤其是他有敏锐的观察力，总能发现一些别人发现不了的蛛丝马迹，因此，成为了光辉镇有名的小神探，皿雄自己也有一个梦想,就是他想成为一个侦探,而且是响誉世界的大侦探,于是他为了这个梦想,他以优异的成绩考上了世界上最有名的侦探学校—福尔摩斯侦探学校。</p><p>今天是皿雄上学的第一天,他很早就来到了学校门口,以非常激动的心情等待大门的开启，他闭上了眼睛，静静地等待着，等待着梦想成真的那一刻。</p><p>忽然，他听到了一阵轻脆的脚步声，他睁开了眼睛，仔细一瞧，是个长相清秀的少年，他背着一个卡通的小背包，慢慢地走了过来，他看着皿雄，皿雄也看着他，两人相视一笑，礼貌的握了一下手。</p><p>“嗨，你好，我叫罗杰，是今年的新生。”</p><p>“哦，你好，我叫皿雄，也是今年的新生，哦，也许我们会在一个班呀。”皿雄笑着说。</p><p>“当然，我想 ，我们已经是好朋友了吧。”罗杰挤了一下眼睛说。</p><p>“哦，当然，到时我们住在一个宿舍吧。”</p><p>“希望如此。”罗杰友好地拍了皿雄一下。</p><p>这时门口已经站了好多人，皿雄看了看表，开学时间到了，慢慢地，校门打开了，一位位老师走了出来，报了一下名字，分别领进了学校，说来也巧，皿雄与罗杰真的分在了一个班，竟也在一个寝室，听到这个消息，皿雄与罗杰又相视一笑。</p><p>原来，皿雄与罗杰是这个学校中成绩最好的两位，根据惯例，头两位都要分在一个班，且分在同一个寝室，所以这也就不足为奇了。</p><p>皿雄与罗杰选择坐在了一起，他们的班主任是个光头，叫查克，首先，查老师不无自豪地说：“我们学校是世界上最好的侦探学校，而我们班是这个学校最好的班级！“</p><p>查老师顿了顿，又说：“现在，你们在这个班，但这并不表示你们以后也在这个班，接下来，我们将用一周的时间对你们进行突然考验，然后，通过你们的表现对你们进行评分，按照分数的高低对你们进行班级的分配，了解了吗？我的同学们。”</p><p>听到这个消息，皿雄心里突然一怔，疑惑着：会是什么考验呢？</p><p>罗杰却拍拍皿雄说：“我们一定会通过的。”</p><p>皿雄微笑着表示同意，心里暗暗钦佩罗杰的自信。</p><p>接着，老师叫大家互相介绍自己……</p><p>跟着，查老师领着大家参观了宿舍。</p><p>就这样，皿雄的侦探生涯开始了</p><p>第一天，相安无事，大家继续互相熟识着，一位位科任老师相继与同学们见面。</p><p>第二天，还是没有什么特殊的事情发生，同学们渐渐放松了警惕，以为不会有什么所谓的考验了</p><p>……</p><p>到了最后一天了，直到晚上还是相安无事，所有的同学，包括皿雄与罗杰，都忘了有考核这一回事了。</p><p>晚上，皿雄与罗杰早早地就睡了。因为今天的天气不太好，所以宿舍灯提早关了。</p><p>忽然，狂风呼啸，只听得唧唧喳喳，鸟儿胡乱飞翔，地上的虫子也赶紧躲了起来，似乎暗示着有什么不详的事即将发生。</p><p>突然，一声枪响划破长空，刚刚入睡的皿雄与罗杰别惊醒了，他们赶紧爬起来，刚站起来，又是一声恐怖的枪声，这次伴随着的，是一阵撕心裂肺的呼号。</p><p>事情严重了，这是人命呀！</p><p>这到底是怎么回事呢？</p><p>皿雄与罗杰来不及想清楚，风一般冲了出去。</p><p>此时，外面已经充满了人，大家都恐惧地紧缩在一起，惊恐地张望着。</p><p>皿雄仔细的注视着四周的风吹草动，突然 ,一阵风吹过,皿雄发现离自己大约五米处的草丛中传来一阵骚动。</p><p>皿雄当机立断，指着草丛大喊道：“是谁！“</p><p>罗杰听到皿雄的声音，呼地一下冲到草丛中，又是突然，罗杰大叫一声：</p><p>“尸体！！“罗杰面目惨白。皿雄听到后，也赶忙冲了过去，只见那是一具用红布包裹着的尸体，周围草丛中也沾满了血迹。</p><p>这是怎么回事？皿雄想着。</p><p>这时，冷静下来的罗杰也开始观察尸体：“这是他杀。“</p><p>“恩，我想也是，可……“皿雄顿了顿说，“我总觉得有些问题？”</p><p>皿雄说着，摸了摸周围的血迹，忽然，他发现了一些异常，那血迹摸起来有些不同寻常，经过缜密的思索之后，皿雄得出结论，这不是血迹，那就是有人故意冒充，可这又是为了什么呢？又看看眼前的尸体，皿雄似乎又觉得不同寻常，真奇怪？</p><p>突然，罗杰说：“那包裹的尸体似乎有一颗钻石。”说完，又指了指那红布</p><p>“哈，我知道了，”皿雄兴奋地说，罗杰明显感觉到皿雄在抽搐，那是人最激动时才会发生的抽搐。</p><p>“哦，你发现了什么呢。”罗杰也很兴奋。</p><p>“我想，我们都被骗了！”</p><p>皿雄转过身去，对那尸体说：“我说得对吗？查老师。”</p><p>所有人都惊呆了，只见那尸体慢慢地爬了起来，说着：“皿雄，你是好样儿的。“</p><p>“可你是怎么发现的？“说着，查老师招呼出了隐藏着的几位老师们。</p><p>“从那儿。“皿雄指着那血迹</p><p>“可你又是怎么发现我的呢？“</p><p>“从您的光头。“</p><p>“哦，看来我该戴个假发。“说完，查老师哈哈大笑。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;(5年级到6年级的暑假写的，读来还有点害羞，嘻嘻QAQ)&lt;/p&gt;
&lt;p&gt;这个故事的主人公叫皿雄，虽然家境贫寒，但是他并没有自暴自弃，他热爱读书，尤其是他有敏锐的观察力，总能发现一些别人发现不了的蛛丝马迹，因此，成为了光辉镇有名的小神探，皿雄自己也有一个梦想,就是他想成为一个
      
    
    </summary>
    
    
      <category term="年少轻狂，幸福时光" scheme="https://nijiehaha.github.io/categories/%E5%B9%B4%E5%B0%91%E8%BD%BB%E7%8B%82%EF%BC%8C%E5%B9%B8%E7%A6%8F%E6%97%B6%E5%85%89/"/>
    
    
      <category term="年少轻狂，幸福时光" scheme="https://nijiehaha.github.io/tags/%E5%B9%B4%E5%B0%91%E8%BD%BB%E7%8B%82%EF%BC%8C%E5%B9%B8%E7%A6%8F%E6%97%B6%E5%85%89/"/>
    
  </entry>
  
  <entry>
    <title>iOS 符号表(dSYM)</title>
    <link href="https://nijiehaha.github.io/2019/04/30/iOS-dSYM/"/>
    <id>https://nijiehaha.github.io/2019/04/30/iOS-dSYM/</id>
    <published>2019-04-30T06:07:14.000Z</published>
    <updated>2019-12-02T02:39:06.941Z</updated>
    
    <content type="html"><![CDATA[<p>今天是个适合学习的日子，嘻嘻嘻QAQ</p><h1 id="什么是符号表"><a href="#什么是符号表" class="headerlink" title="什么是符号表"></a>什么是符号表</h1><p>它是内存地址与函数名，文件名，行号的映射表。大概长这样：<br><code>&lt;起始地址&gt; &lt;结束地址&gt; &lt;函数&gt; [&lt;文件名:行号&gt;]</code></p><p>符号表文件<code>.dSYM</code>实际上是从Mach-O文件中抽取调试信息而得到的文件目录，实际用于保存调试信息的文件夹是<code>DWARF</code></p><p>如果利用这些二进制的地址信息来定位问题是不可能的，因此我们需要将这些二进制的地址信息还原成源代码种的函数以及行号，这时候就需要符号表了。</p><p>特别地，如果使用bugly来做crash上报管理，只需要将构建时的符号表上传到bugly，当应用crash时，bugly会将crash信息上报到bugly，然后会自动替我们将原始的crash的二进制堆栈信息还原成包含行号的源代码文件信息，我们就可以快速定位问题。（好想用bugly QAQ）</p><h1 id="符号表如何产生呢"><a href="#符号表如何产生呢" class="headerlink" title="符号表如何产生呢"></a>符号表如何产生呢</h1><p>生成符号表的步骤是在处理pinfo.plst文件之后，最初生成的符号表并不是在我们看到的归档文件内部，而是放在构建的一个临时目录中，最后才拷贝到归档目录下的，大概是这样，不过这其实没那么重要，了解一下。</p><h2 id="1-Xcode自动生成"><a href="#1-Xcode自动生成" class="headerlink" title="1.Xcode自动生成"></a>1.Xcode自动生成</h2><p>Xcode会在编译工程或者归档时自动为我们生成.dSYM文件，当然我们也可以通过更改Xcode的若干项Build Settings来阻止它那么干。</p><h2 id="2-手动生成"><a href="#2-手动生成" class="headerlink" title="2.手动生成"></a>2.手动生成</h2><p>另一种方式是通过命令行从Mach-O文件中手工提取，比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/dsymutil /Users/hahaha/Library/Developer/Xcode/DerivedData/YourApp-cqvijavqbptjyhbwewgpdmzbmwzk/Build/Products/Debug-iphonesimulator/YourApp.app/YourApp -o YourApp.dSYM</span><br></pre></td></tr></table></figure></p><p>该方式通过Xcode提供的工具<code>dsymutil</code>，从项目编译结果<code>.app</code>目录下的Mach-O文件中提取出调试符号表文件。实际上Xcode也是通过这种方式来生成符号表文件。</p><p><strong>注意：debug配置默认不会生成符号表，并且每次构建时都会产生不同的符号表，每个符号表都有一个唯一的uuid，和每次构建对应</strong></p><h1 id="如何定位dSYM文件"><a href="#如何定位dSYM文件" class="headerlink" title="如何定位dSYM文件"></a>如何定位dSYM文件</h1><p>dSYM文件其实是一个带后缀的文件夹形式的文件，内容如下所示:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">yourAppName.app.dSYM/</span><br><span class="line">└── Contents</span><br><span class="line">    ├── Info.plist</span><br><span class="line">    └── Resources</span><br><span class="line">        └── DWARF</span><br><span class="line">            └── yourAppName</span><br></pre></td></tr></table></figure><p>真实的符号表文件其实是一个二进制文件，bugly提供了脚本将这个二进制文件转为文本形式的文件，文件的内容其实就是二进制地址对和源代码文件，行号以及函数名字的对应关系</p><h1 id="如何查看dSYM文件的uuid"><a href="#如何查看dSYM文件的uuid" class="headerlink" title="如何查看dSYM文件的uuid"></a>如何查看dSYM文件的uuid</h1><p>iOS App崩溃时会有此次构建的uuid信息，如果要将崩溃堆栈还原成对应的源代码文件信息，需要根据这个uuid找到对应的符号表的uuid，这样才能正确还原</p><p>总结下来有2种方式:<strong>dwarfdump</strong>，<strong>atos</strong> (网上教程很多，使用起来也都很简单)</p><h1 id="CrashLog相关"><a href="#CrashLog相关" class="headerlink" title="CrashLog相关"></a>CrashLog相关</h1><p>有了符号表文件，有了崩溃日志文件，在解析之前一定要确保二者的对应关系，否则就算按照下述步骤解析出内容也肯定是不准确的。二者的对应关系可以通过UUID来确定。<br>其中，崩溃日志中的地址和符号表中的地址不是完全一样的，需要分别计算.<br><code>运行时堆栈地址 = 运行时起始地址 + 偏移量</code><br><code>符号表堆栈地址 = 符号表起始地址 + 偏移量</code></p><p>计算出地址，再利用xcode工具，就能很方便的定位crash位置了</p><h1 id="原理简介"><a href="#原理简介" class="headerlink" title="原理简介"></a>原理简介</h1><h2 id="DWARF简介"><a href="#DWARF简介" class="headerlink" title="DWARF简介"></a>DWARF简介</h2><p><code>DWARF</code>（DebuggingWith Arbitrary Record Formats），是ELF和Mach-O等文件格式中用来存储和处理调试信息的标准格式，<code>.dSYM</code>中真正保存符号表数据的是<code>DWARF</code>文件。<code>DWARF</code>中不同的数据都保存在相应的<code>section</code>（节）中，ELF文件里所有的<code>section</code>名称都以<code>&quot;.debug_&quot;</code>开头，如下表所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">| Section Name         | Contents                                          |</span><br><span class="line">| -------------------- | ------------------------------------------------  |</span><br><span class="line">| .debug_abbrev        | Abbreviations used in the .debug_info section     |</span><br><span class="line">| .debug_aranges       | A mapping between memory address and compilation  |</span><br><span class="line">| .debug_frame         | Call Frame Information                            |</span><br><span class="line">| .debug_info          | The core DWARF data containing DIEs               |</span><br><span class="line">| .debug_line          | Line Number Program                               |</span><br><span class="line">| .debug_loc           | Macro descriptions                                |</span><br><span class="line">| .debug_macinfo       | A lookup table for global objects and functions   |</span><br><span class="line">| .debug_pubnames      | A lookup table for global objects and functions   | </span><br><span class="line">| .debug_pubtypes      | A lookup table for global types                   |</span><br><span class="line">| .debug_ranges        | Address ranges referenced by DIEs                 |</span><br><span class="line">| .debug_str           | String table used by .debug_info                  |</span><br></pre></td></tr></table></figure><p>Mach-O中关于section的命名和ELF稍有区别，把名称前的.换成了_，例如<code>.debug_info</code>变成了<code>_debug_info</code></p><h2 id="section信息提取"><a href="#section信息提取" class="headerlink" title="section信息提取"></a>section信息提取</h2><p>保存在DAWARF中的信息是高度压缩的，可以通过dwarfdump命令从中提取出可读信息。前文所述的那些section中，定位CrashLog只需要用到<code>.debug_info</code>和<code>.debug_line</code>。由于解析出来的数据量较大，为了方便查看，就将其保存在文本中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.debug_info</span><br><span class="line">$ dwarfdump -e --debug-info YourPath/YourApp.dSYM/Contents/Resources/DWARF &gt; info-e.txt</span><br><span class="line">.debug_line</span><br><span class="line">$ dwarfdump -e --debug-line YourPath/YourApp.dSYM/Contents/Resources/DWARF &gt; line-e.txt</span><br></pre></td></tr></table></figure><h2 id="解析崩溃地址"><a href="#解析崩溃地址" class="headerlink" title="解析崩溃地址"></a>解析崩溃地址</h2><p><code>.debug_info</code>中最基本的描述单元为DIE（Debug Information Entry），首先我们要根据符号表崩溃地址从<code>.debug_info</code>中取出包含这个地址的DIE单元。<br>从上述DIE中我们可以获取到这些信息:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">崩溃所在源码文件</span><br><span class="line">发生崩溃的方法</span><br><span class="line">发生崩溃的方法在源文件中的行号</span><br></pre></td></tr></table></figure></p><p>截止目前，我们可以获取到发生了崩溃的方法的相关信息，但要想确定崩溃发生的具体行号，还需要<code>.debug_line</code>的帮助。</p><p><code>.debug_line</code>以一个方法为基本块，即方法中每一行对应的符号表地址。通过<code>.debug_info</code>得知崩溃发生的方法地址范围，通过起始地址去解析<code>.debug_line</code>得到的<code>line-e.txt</code>中直接搜索即可得到崩溃所在方法的<code>.debug_line</code>数据</p><p><code>.debug_line</code>段的第一行内容标识了该方法的起始符号表地址，行号及方法所在文件路径，通过之前得到的崩溃地址，即可得知崩溃行。</p><p>至此我们已经根据崩溃地址解析出了崩溃发生位置的详细信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">崩溃所在源码文件</span><br><span class="line">发生崩溃的方法</span><br><span class="line">发生崩溃的方法在源文件中的行号</span><br><span class="line">崩溃发生在源文件中得行号</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天是个适合学习的日子，嘻嘻嘻QAQ&lt;/p&gt;
&lt;h1 id=&quot;什么是符号表&quot;&gt;&lt;a href=&quot;#什么是符号表&quot; class=&quot;headerlink&quot; title=&quot;什么是符号表&quot;&gt;&lt;/a&gt;什么是符号表&lt;/h1&gt;&lt;p&gt;它是内存地址与函数名，文件名，行号的映射表。大概长这样：
      
    
    </summary>
    
    
      <category term="iOS" scheme="https://nijiehaha.github.io/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://nijiehaha.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>浅谈runloop</title>
    <link href="https://nijiehaha.github.io/2018/10/08/%E6%B5%85%E8%B0%88runloop/"/>
    <id>https://nijiehaha.github.io/2018/10/08/%E6%B5%85%E8%B0%88runloop/</id>
    <published>2018-10-08T03:18:09.000Z</published>
    <updated>2020-01-20T03:06:01.346Z</updated>
    
    <content type="html"><![CDATA[<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="noopener">深入理解RunLoop</a></p><p><code>RunLoop</code> 是 iOS 和 OSX 开发中的概念，首先，先简单介绍我目前已知的东西</p><h1 id="RunLoop和线程的关系："><a href="#RunLoop和线程的关系：" class="headerlink" title="RunLoop和线程的关系："></a>RunLoop和线程的关系：</h1><ul><li><code>RunLoop</code>的作用就是用来管理线程的，当线程的<code>RunLoop</code>开启后，线程就会在执行完任务后，处于休眠状态，随时等待接受新的任务，而不是退出。</li><li>只有主线程的<code>RunLoop</code>是默认开启的，所以程序在开启后，会一直执行，不会退出，其他线程的<code>RunLoop</code>如果需要开启，就手动开启。</li></ul><h1 id="RunLoop内部是如何实现的："><a href="#RunLoop内部是如何实现的：" class="headerlink" title="RunLoop内部是如何实现的："></a>RunLoop内部是如何实现的：</h1><ul><li>有一个判断循环的条件，满足条件，就一直循环。</li><li>线程得到唤醒事件被唤醒，事件处理完毕以后，回到睡眠状态，等待下次唤醒。</li></ul><p>上面的谈论可能太笼统了，下面我们来详细谈谈RunLoop的那些事儿：</p><h1 id="RunLoop的概念："><a href="#RunLoop的概念：" class="headerlink" title="RunLoop的概念："></a>RunLoop的概念：</h1><p>一般来讲，一个线程一次只能执行一个任务，执行完成后线程就会退出。所以我们需要这样一个机制，让线程能随时处理事件。</p><p>首先类似这样的模型，一般被称为 <code>Event Loop</code> ，这样的模型的关键在于：如何管理事件和消息，如何让线程在没有处理消息时休眠以避免资源占用，在有消息到来时立刻被唤醒。<br>所以，实际上，<code>RunLoop</code>是一个对象，这个对象管理了其需要处理的事件和消息，并提供了一个函数来执行 <code>Event Loop</code> 的逻辑。</p><p>线程执行了 <code>Event Loop</code> 这个函数后，就会一直处于这个函数内部<code>接受消息-&gt;等待-&gt;处理</code>的循环中，直到这个循环结束（例如<code>quit</code>），函数返回。</p><blockquote><p><code>OSX/iOS</code>中，提供了两个这样的对象：<code>NSRunLoop</code>和<code>CFRunLoopRef</code>。<br><code>CFRunLoopRef</code>是在<code>CoreFoundation</code>框架内的，它提供了纯c的<code>API</code>，且都是线程安全的<br><code>NSRunLoop</code>是基于<code>CFRunLoopRef</code>的封装，提供了面向对象的<code>API</code>，但是这些<code>API</code>不是线程安全的</p></blockquote><h2 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h2><ul><li>关于线程安全：简单理解为一个方法或者一个实例可以在多线程环境中使用 而不会出现问题</li><li>产生线程不安全的原因：在我理解下，这种情况大约是一或多个线程向相同的资源做了写操作才能发生，只要资源本身没有变化，那么多个线程读取相同资源应该是安全的（关于这一点，还需要查资料）</li></ul><blockquote><p>苹果不允许直接创建RunLoop，它提供了两个自动获取的函数CFRunLoopGetMain()和CFRunLoopGetCurrent(), 线程和RunLoop之间是一一对应的，其关系是保存在一个全局的Dictionary里。<br>线程刚创建时并没有RunLoop，如果你不主动获取，那它一直都不会有。RunLoop的创建是发生在第一次获取时，RunLoop的销毁是发生在线程结束时。你只能在一个线程的内部获取其RunLoop（主线程除外）<br>（RunLoop在NSRunLoop的实践，还需要自己去编码感受一下，source，timer，mode，Observer）</p></blockquote><h1 id="RunLoop的底层实现："><a href="#RunLoop的底层实现：" class="headerlink" title="RunLoop的底层实现："></a>RunLoop的底层实现：</h1><p><code>RunLoop</code> 的核心是基于 <code>mach port</code>  的，其进入休眠时调用的函数是  <code>mach_msg()</code><br><code>OSX/iOS</code> 的系统架构基本上分为：应用层（<code>SpringBoard</code>等），应用框架层（<code>Cocoa</code>等框架），核心框架层（核心框架，<code>openGL</code>等），<code>Darwin</code>（操作系统核心，包括内核，驱动等）</p><h2 id="Darwin这个核心的架构："><a href="#Darwin这个核心的架构：" class="headerlink" title="Darwin这个核心的架构："></a>Darwin这个核心的架构：</h2><p><img src="/images/深入理解runloop/runloop.png" alt="RunLoop.png"></p><p>在硬件层上面的三个组成部分：<code>Mach</code>、<code>BSD</code>、<code>IOKit</code>（还有其他内容），共同组成了XNU 内核.</p><p>XNU 内核的内环被称作 <code>Mach</code>，其作为一个微内核，仅提供了诸如处理器调度、<code>IPC</code> (进程间通信)等非常少量的基础服务。</p><p><code>BSD</code> 层可以看作围绕 <code>Mach</code> 层的一个外环，其提供了诸如进程管理、文件系统和网络等功能。</p><p><code>IOKit</code> 层是为设备驱动提供了一个面向对象(C++)的一个框架。</p><p><code>Mach</code> 本身提供的 API 非常有限，而且苹果也不鼓励使用 <code>Mach</code> 的 API，但是这些API非常基础，如果没有这些API的话，其他任何工作都无法实施。在 <code>Mach</code> 中，所有的东西都是通过自己的对象实现的，进程、线程和虚拟内存都被称为”对象”。和其他架构不同， <code>Mach</code> 的对象间不能直接调用，只能通过消息传递的方式实现对象间的通信。”消息”是 <code>Mach</code> 中最基础的概念，消息在两个端口 (port) 之间传递，这就是 <code>Mach</code> 的 <code>IPC</code> (进程间通信) 的核心。</p><p>一条 <code>Mach</code> 消息实际上就是一个二进制数据包 (BLOB)，其头部定义了当前端口 <code>local_port</code> 和目标端口 <code>remote_port</code>，发送和接受消息是通过同一个 API 进行的，其 <code>option</code> 标记了消息传递的方向。<br>为了实现消息的发送和接收，<code>mach_msg()</code>函数实际上是调用了一个 <code>Mach</code> 陷阱 (trap)，即函数<code>mach_msg_trap()</code>，陷阱这个概念在 <code>Mach</code> 中等同于系统调用。当你在用户态调用 <code>mach_msg_trap()</code>时会触发陷阱机制，切换到内核态；内核态中内核实现的 <code>mach_msg()</code> 函数会完成实际的工作。</p><blockquote><p>总结： <code>RunLoop</code> 的核心就是一个 <code>mach_msg()</code> ，RunLoop 调用这个函数去接收消息，如果没有别人发送 port 消息过来，内核会将线程置于等待状态。例如你在模拟器里跑起一个 iOS 的 App，然后在 App 静止时点击暂停，你会看到主线程调用栈是停留在 <code>mach_msg_trap()</code> 这个地方。 </p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;参考&quot;&gt;&lt;a href=&quot;#参考&quot; class=&quot;headerlink&quot; title=&quot;参考&quot;&gt;&lt;/a&gt;参考&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://blog.ibireme.com/2015/05/18/runloop/&quot; target=&quot;_blank&quot;
      
    
    </summary>
    
    
      <category term="iOS" scheme="https://nijiehaha.github.io/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://nijiehaha.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>NTA打洞</title>
    <link href="https://nijiehaha.github.io/2018/09/11/NTA%E6%89%93%E6%B4%9E/"/>
    <id>https://nijiehaha.github.io/2018/09/11/NTA%E6%89%93%E6%B4%9E/</id>
    <published>2018-09-11T08:30:21.000Z</published>
    <updated>2019-12-02T02:39:49.399Z</updated>
    
    <content type="html"><![CDATA[<h1 id="NTA打洞"><a href="#NTA打洞" class="headerlink" title="NTA打洞"></a>NTA打洞</h1><h2 id="只有一方处于NAT设备后"><a href="#只有一方处于NAT设备后" class="headerlink" title="只有一方处于NAT设备后"></a>只有一方处于NAT设备后</h2><p>此种情况是所有P2P场景中最简单的，它使用一种被称为“反向链接技术”来解决这个问题。大致的原理如下所述。</p><p>如图所示，客户端A位于<code>NAT</code>之后，它通过<code>TCP</code>端口1234连接到服务器的<code>TCP</code>端口1235上，NAT设备为这个连接重新分配了<code>TCP</code>端口62000。客户端B也通过TCP端口1234连接到服务器端口1235上。A和B从服务器处获知的对方的外网地址二元组<code>{IP地址:端口号}</code>分别为<code>{138.76.29.7:1234}</code>和<code>{155.99.25.11:62000}</code>，它们在各自的本地端口上进行侦听。</p><p>由于B 拥有外网<code>IP</code>地址，所以A要发起与B的通信，可以直接通过<code>TCP</code>连接到B。但如果B尝试通过TCP连接到A进行<code>P2P</code>通信，则会失败，原因是A位于<code>NAT</code>设备后，虽然B发出的<code>TCP</code> SYN请求能够到达NAT设备的端口62000，但<code>NAT</code>设备会拒绝这个连接请求。要想与<code>Client</code> A通信， B不是直接向A发起连接，而是通过服务器给A转发一个连接请求，反过来请求A连接到B（即进行反向链接），A在收到从服务器转发过来的请求以后，会主动向B发起一个<code>TCP</code>的连接请求，这样在<code>NAT</code>设备上就会建立起关于这个连接的相关表项，使A和B之间能够正常通信，从而建立起它们之间的<code>TCP</code>连接。</p><p><img src="/images/NAT打洞/反向链接.jpg" alt="反向链接示意图"></p><h2 id="双方都处于NAT后设备后"><a href="#双方都处于NAT后设备后" class="headerlink" title="双方都处于NAT后设备后"></a>双方都处于NAT后设备后</h2><h3 id="NAT设备部署情况"><a href="#NAT设备部署情况" class="headerlink" title="NAT设备部署情况"></a>NAT设备部署情况</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">两客户端都处于NAT设备背后也有很多情况,如:</span><br><span class="line">都处在同一NAT设备后.</span><br><span class="line">随直连的不是同一个NAT设备,中间有很多NAT转接,但顶端接入公网ip的NAT(网络服务商的路由)是同一个.</span><br></pre></td></tr></table></figure><p>像第一种情况,就是在同一个以太网中,这种可以直接使用内网ip进行直连最优.<br>但是想第二种情况,因为嵌套在不同的内网中,都使用的保留ip地址,或许会存在与客户端本身所在的内网地址重复的可能性,所以还是以外网ip+端口来进行打洞最为稳妥.</p><p>因为有<code>Hairpin</code>技术,它可以让两台位于同一台NAT网关后面的主机,通过对方的公网端口互相访问.</p><h3 id="ICE"><a href="#ICE" class="headerlink" title="ICE"></a>ICE</h3><blockquote><p>ICE的全称Interactive Connectivity Establishment（互动式连接建立），由IETF的MMUSIC工作组开发出来的，它所提供的是一种框架，使各种NAT穿透技术可以实现统一。ICE跟STUN和TURN不一样，ICE不是一种协议，而是一个<strong>框架</strong>（Framework），它整合了STUN和TURN。</p></blockquote><h3 id="TURN"><a href="#TURN" class="headerlink" title="TURN"></a>TURN</h3><p>TURN(Traversal Using Relays around NAT)TURN与STUN的共同点都是通过修改应用层中的私网地址达到NAT穿透的效果，异同点是TURN是通过两方通讯的“中间人”方式实现穿透</p><p>TURN服务器相比较STUN服务器,多了中继的功能,对于无法端对端的服务器,可以进包转发</p><h3 id="STUN"><a href="#STUN" class="headerlink" title="STUN"></a>STUN</h3><p>STUN服务器（Simple Traversal of User Datagram Protocol Through Network Address Translators）是一个轻量级协议,是基于UDP的完整的穿透NAT的解决方案.在进行NAT穿透时我们需要STUN服务器.</p><p>STUN服务器主要做了:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">判断客户端的NAT类型(NAT分四种类型)。</span><br><span class="line">接受客户端的请求,返回其需要连接的外网地址。</span><br><span class="line">协调客户端间打洞。</span><br></pre></td></tr></table></figure></p><h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><h4 id="是否处于NAT后-作为iOS肯定是在NAT后的-不用判断的"><a href="#是否处于NAT后-作为iOS肯定是在NAT后的-不用判断的" class="headerlink" title="是否处于NAT后(作为iOS肯定是在NAT后的,不用判断的)"></a>是否处于NAT后(作为iOS肯定是在NAT后的,不用判断的)</h4><p>客户端向STUN服务器发送UDP包,STUN将收到的包的IP包在UDP包中进行返回,客户端收到包后和自己的IP做比较,不一样则处在NAT后.</p><h4 id="判断NAT类型"><a href="#判断NAT类型" class="headerlink" title="判断NAT类型"></a>判断NAT类型</h4><p>当处在NAT后则要判断NAT类型,为了判断STUN服务器需要两个ip,ip1和ip2.</p><p>客户端当得知自己处在NAT设备后时,再向服务端ip1发送判断请求.</p><p><strong>FULL Cone NAT</strong></p><blockquote><p>服务器收到后从ip2向客户端的公网ip发送包,若客户端能收到,则为 完全雏形NAT.</p></blockquote><p><strong>判断是否为 对称NAT</strong></p><blockquote><p> 客户端再从不同的port 想服务端发包,若客户端收到的外网端口(此处的端口号是指NAT表中ip后对应的端口号,而不是主机为外网服务的端口号)不一致,则为对称NAT,一致则不为对称NAT</p></blockquote><p><strong>Restrict Cone NAT /Port Restrict NAT</strong></p><blockquote><p>服务端从ip1的不同端口向客户端发包,若客户端收到 则为<code>Restrict Cone NAT</code>,收不到则为 <code>Port RestrictNAT</code>.</p></blockquote><h4 id="协调打洞"><a href="#协调打洞" class="headerlink" title="协调打洞"></a>协调打洞</h4><p><strong>Full Cone NAT</strong></p><blockquote><p>此时什么都不需要STUN做,只要知道对方公网ip+端口号 客户端间可以直接通讯</p></blockquote><p><strong>Restrict Cone 或 Port Restrict</strong></p><blockquote><p>此时需要TURN服务器协调两客户端互相向对方公网ip发包, 因为在NAT设备看起来,互相发包都是在向公网发包,这时在NAT表上就会开启对指定外网ip+端口号的通道.这样就完成了打洞</p></blockquote><p><strong>对称NAT</strong></p><blockquote><p>对于对称NAT是无法打洞的,因为客户端向STUN服务器发包的外网ip+端口号 与向其他客户端发包的外网ip+端口号是不一样的.所以无法沟通,这时就需要TURN服务器,两个客户端都对其进行长连接,进行包的转发.</p></blockquote><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="http://www.52im.net/thread-542-1-1.html" target="_blank" rel="noopener">http://www.52im.net/thread-542-1-1.html</a><br><a href="http://www.52im.net/thread-557-1-1.html" target="_blank" rel="noopener">http://www.52im.net/thread-557-1-1.html</a><br><a href="http://www.h3c.com.cn/MiniSite/Technology_Circle/Net_Reptile/The_Five/Home/Catalog/201206/747038_97665_0.htm" target="_blank" rel="noopener">http://www.h3c.com.cn/MiniSite/Technology_Circle/Net_Reptile/The_Five/Home/Catalog/201206/747038_97665_0.htm</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;NTA打洞&quot;&gt;&lt;a href=&quot;#NTA打洞&quot; class=&quot;headerlink&quot; title=&quot;NTA打洞&quot;&gt;&lt;/a&gt;NTA打洞&lt;/h1&gt;&lt;h2 id=&quot;只有一方处于NAT设备后&quot;&gt;&lt;a href=&quot;#只有一方处于NAT设备后&quot; class=&quot;headerli
      
    
    </summary>
    
    
      <category term="网络" scheme="https://nijiehaha.github.io/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="网络" scheme="https://nijiehaha.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>NAT与内网穿透</title>
    <link href="https://nijiehaha.github.io/2018/09/11/NAT%E4%B8%8E%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"/>
    <id>https://nijiehaha.github.io/2018/09/11/NAT%E4%B8%8E%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/</id>
    <published>2018-09-11T07:55:27.000Z</published>
    <updated>2019-12-02T02:39:30.481Z</updated>
    
    <content type="html"><![CDATA[<h1 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h1><h2 id="NAT是什么"><a href="#NAT是什么" class="headerlink" title="NAT是什么"></a>NAT是什么</h2><blockquote><p>网络地址转换,就是替换<code>IP</code>报文头部的地址信息.由于<code>IPv4</code>地址有限,不可能为每一个上网设备分配一个<code>ip</code>,而NAT就是来解决这个问题的.我们在上网时很有可能处在一个<code>NAT</code>设备之后, NAT设备会在ip包通过时会修改其 源/目标<code>IP</code>地址,有时还会修改<code>TCP/UDP</code>协议的端口号,从而实现多台设备使用同一外网<code>IP</code>进行互联网通讯</p></blockquote><p><img src="/images/NAT与内网穿透/NAT映射表1.jpg" alt="NAT映射表.png"></p><p>如上,三台设备都使用<em>120.131.92.21</em>这一公网IP。</p><p>而对于这三台设备分别从各自端口发出的<code>TCP/UDP</code>请求,则映射至NAT设备不同的端口上, 记录在<code>NAT</code>表上, 这样就区分了某个请求试试来自哪个设备的哪个端口上.</p><h2 id="NAT特点"><a href="#NAT特点" class="headerlink" title="NAT特点"></a>NAT特点</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">网络被分为私网,公网两部分,NAT网关设置私网到公网的路由出口。</span><br><span class="line"></span><br><span class="line">网络只能由私网侧发起,公网无法主动访问私网主机(是这样设计的,但是可以通过打洞)。</span><br><span class="line"></span><br><span class="line">NAT网关在两个访问方向上完成两次地址的转换,出口替换源地址,入口替换目的地址。</span><br><span class="line"></span><br><span class="line">NAT网关的存在对通信双方保持透明。</span><br><span class="line"></span><br><span class="line">NAT网关为了实现双向翻译,需要维持一张关联表,将会话信息保存。</span><br></pre></td></tr></table></figure><h2 id="NAT的副作用"><a href="#NAT的副作用" class="headerlink" title="NAT的副作用"></a>NAT的副作用</h2><p><strong>NAT表的淘汰</strong></p><blockquote><p>当NAT表对应的记录在一段时间内没有通讯时,网络运营商就会将其淘汰掉,若此时外网还通过原来记录的外网IP地址和内网设备进行通讯则会不通.</p></blockquote><p><strong>NAT墙</strong></p><blockquote><p>当外界对内网的请求到达NAT设备时,若不符合NAT设备和NAT表的要求,<br>则会被丢弃,这样若想实现ip地址不固定客户端间通讯则需要额外的打洞操作<br>(需要心跳包刷新NAT表重置时间)</p></blockquote><p><strong>端对端通信模型的破坏</strong></p><blockquote><p>NAT实现了将多个内部主机发出的链接被复用到一个ip上,这样无法基于ip对主机进行追踪,这样服务器不能简单的将同一ip与主机挂钩.这样再统计信息和防止DDOS攻击时都会变得复杂, 有时,若-个NAT设备拥有多个IP地址时,一组关联的会话可能会被分配到不同公网ip里,总之NAT隐蔽了通讯的另一端.</p></blockquote><h2 id="NAT类型"><a href="#NAT类型" class="headerlink" title="NAT类型"></a>NAT类型</h2><p><strong>Full Cone NAT(完全雏形NAT)</strong></p><blockquote><p>设备比较少,一旦内部主机端口在NAT网关完成端口映射,则后续外网任一主机都可以通过这映射好的端口进行访问</p></blockquote><p><strong>Restricted Cone NAT (限制雏形NAT)</strong></p><blockquote><p>相较与全雏形NAT,在完成端口映射后,对IP地址有限制,只有内网对外访问过的ip地址才可以对该端口进行连接</p></blockquote><p><strong>Port Restricted Cone NAT(端口限制雏形NAT)</strong></p><blockquote><p>相较于限制雏形NAT,在端口上也加以限制,<br>只有内网向该ip与端口发送过信息才能对其访问</p></blockquote><p><strong>Symmetric NAT (对称NAT)</strong></p><blockquote><p>也就是说,虽然是同一个内网主机,对不同的外网ip+端口访问时,在NAT表上会映射成不同的端口号</p></blockquote><p><em>注意:</em></p><p>事实上，这些术语的引入是很多混淆的起源。现实中的很多NAT设备是将这些转换方式<strong>混合</strong>在一起工作的，而不单单使用一种，所以这些术语只适合描述一种<strong>工作方式</strong>，而不是一个设备。比如，很多NAT设备对内部发出的连接使用对称型NAT方式，而同时支持静态的端口映射，后者可以被看作是全锥型NAT方式。而有些情况下，NAT设备的一个公网地址和端口可以同时映射到内部几个服务器上以实现负载分担，比如一个对外提供WEB服务器的站点可能是有成百上千个服务器在提供HTTP服务，但是对外却表现为一个或少数几个IP地址。</p><h1 id="内网穿透"><a href="#内网穿透" class="headerlink" title="内网穿透"></a>内网穿透</h1><h2 id="应用层网管-ALG"><a href="#应用层网管-ALG" class="headerlink" title="应用层网管(ALG)"></a>应用层网管(ALG)</h2><blockquote><p>普通NAT实现了对UDP或TCP报文头中的的IP地址及端口转换功能，但对应用层数据载荷中的字段无能为力，在许多应用层协议中，比如多媒体协议（H.323、SIP等）、FTP、SQLNET等，TCP/UDP载荷中带有地址或者端口信息，这些内容不能被NAT进行有效的转换，就可能导致问题。而NAT ALG（Application Level Gateway，应用层网关）技术能对多通道协议进行应用层报文信息的解析和地址转换，将载荷中需要进行地址转换的IP地址和端口或者需特殊处理的字段进行相应的转换和处理，从而保证应用层通信的正确性。</p></blockquote><p>例如，FTP应用就由数据连接和控制连接共同完成，而且数据连接的建立动态地由控制连接中的载荷字段信息决定，这就需要ALG来完成载荷字段信息的转换，以保证后续数据连接的正确建立。</p><p><img src="/images/NAT与内网穿透/ALG_RTC.jpg" alt="图片.png"></p><p>图中私网侧的主机要访问公网的FTP服务器。NAT设备上配置了私网地址192.168.1.2到公网地址8.8.8.11的映射，实现地址的NAT转换，以支持私网主机对公网的访问。组网中，若没有ALG对报文载荷的处理，私网主机发送的PORT报文到达服务器端后，服务器无法根据私网地址进行寻址，也就无法建立正确的数据连接。整个通信过程包括如下四个阶段：</p><p>(1) 私网主机和公网FTP服务器之间通过TCP三次握手成功建立控制连接。</p><p>(2) 控制连接建立后，私网主机向FTP服务器发送PORT报文，报文中携带私网主机指定的数据连接的目的地址和端口，用于通知服务器使用该地址和端口和自己进行数据连接。</p><p>(3) PORT报文在经过支持ALG特性的NAT设备时，<strong>报文载荷中的私网地址和端口会被转换成对应的公网地址和端口</strong>。即设备将收到的PORT报文载荷中的私网地址192.168.1.2转换成公网地址8.8.8.11，端口1084转换成12487。</p><p>(4) 公网的FTP服务器收到PORT报文后，解析其内容，并向私网主机发起数据连接，该数据连接的目的地址为8.8.8.11，目的端口为12487（注意：一般情况下，该报文源端口为20，但由于FTP协议没有严格规定，有的服务器发出的数据连接源端口为大于1024的随机端口，如本例采用的是wftpd服务器，采用的源端口为3004）。由于该目的地址是一个公网地址，因此后续的数据连接就能够成功建立，从而实现私网主机对公网服务器的访问。</p><p>总而言之,在ALG中配置的支持的协议,可以实现逆向访问。</p><h2 id="中间件技术"><a href="#中间件技术" class="headerlink" title="中间件技术"></a>中间件技术</h2><blockquote><p>这也是一种通过开发通用方法解决NAT穿越问题的努力。与前者不同之处是，NAT网关是这一解决方案的参与者。与ALG的不同在于，客户端会参与网关公网映射信息的维护，此时NAT网关只要理解客户端的请求并按照要求去分配转换表，不需要自己去分析客户端的应用层数据。其中UPnP就是这样一种方法。UPnP中文全称为通用即插即用，是一个通用的网络终端与网关的通信协议，具备信息发布和管理控制的能力。其中，网关映射请求可以为客户动态添加映射表项。此时，NAT不再需要理解应用层携带的信息，只转换IP地址和端口信息。而客户端通过控制消息或信令发到公网侧的信息中，直接携带公网映射的IP地址和端口，接收端可以按照此信息建立数据连接。NAT网关在收到数据或连接请求时，按照UPnP建立的表项只转换地址和端口信息，不关心内容，再将数据转发到内网。这种方案需要网关、内部主机和应用程序都支持UPnP技术，且组网允许内部主机和NAT网关之间可以直接交换UPnP信令才能实施。</p></blockquote><h2 id="中继代理技术"><a href="#中继代理技术" class="headerlink" title="中继代理技术"></a>中继代理技术</h2><blockquote><p>准确说它不是NAT穿越技术，而是NAT旁路技术。简单说，就是在NAT网关所在的位置旁边放置一个应用服务器，这个服务器在内部网络和外部公网分别有自己的网络连接。客户端特定的应用产生网络请求时，将定向发送到应用代理服务器。应用代理服务器根据代理协议解析客户端的请求，再从服务器的公网侧发起一个新的请求，把客户端请求的内容中继到外部网络上，返回的相应反方向中继。这项技术和ALG有很大的相似性，它要求为每个应用类型部署中继代理业务，中间服务器要理解这些请求。</p></blockquote><h2 id="特定协议的自穿越技术"><a href="#特定协议的自穿越技术" class="headerlink" title="特定协议的自穿越技术"></a>特定协议的自穿越技术</h2><blockquote><p>在所有方法中最复杂也最可靠的就是自己解决自己的问题。比如IKE和IPsec技术，在设计时就考虑了到如何穿越NAT的问题。因为这个协议是一个自加密的协议并且具有报文防修改的鉴别能力，其他通用方法爱莫能助。因为实际应用的NAT网关基本都是NAPT方式，所有通过传输层协议承载的报文可以顺利通过NAT。IKE和IPsec采用的方案就是用UDP在报文外面再加一层封装，而内部的报文就不再受到影响。IKE中还专门增加了NAT网关是否存在的检查能力以及绕开NAT网关检测IKE协议的方法。</p></blockquote><h2 id="探针技术STUN和TURN"><a href="#探针技术STUN和TURN" class="headerlink" title="探针技术STUN和TURN"></a>探针技术STUN和TURN</h2><blockquote><p>所谓探针技术，是通过在所有参与通信的实体上安装探测插件，以检测网络中是否存在NAT网关，并对不同NAT模型实施不同穿越方法的一种技术。STUN服务器被部署在公网上，用于接收来自通信实体的探测请求，服务器会记录收到请求的报文地址和端口，并填写到回送的响应报文中。客户端根据接收到的响应消息中记录的地址和端口与本地选择的地址和端口进行比较，就能识别出是否存在NAT网关。如果存在NAT网关，客户端会使用之前的地址和端口向服务器的另外一个IP发起请求，重复前面的探测。然后再比较两次响应返回的结果判断出NAT工作的模式。由前述的一对多转换模型得知，除对称型NAT以外的模型，NAT网关对内部主机地址端口的映射都是相对固定的，所以比较容易实现NAT穿越。而对称型NAT为每个连接提供一个映射，使得转换后的公网地址和端口对不可预测。此时TURN可以与STUN绑定提供穿越NAT的服务，即在公网服务器上提供一个“地址端口对”，所有此“地址端口对”接收到的数据会经由探测建立的连接转发到内网主机上。TURN分配的这个映射“地址端口对”会通过STUN响应发给内部主机，后者将此信息放入建立连接的信令中通知通信的对端。这种探针技术是一种通用方法，不用在NAT设备上为每种应用协议开发功能，相对于ALG方式有一定普遍性。但是TURN中继服务会成为通信瓶颈。而且在客户端中增加探针功能要求每个应用都要增加代码才能支持。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;NAT&quot;&gt;&lt;a href=&quot;#NAT&quot; class=&quot;headerlink&quot; title=&quot;NAT&quot;&gt;&lt;/a&gt;NAT&lt;/h1&gt;&lt;h2 id=&quot;NAT是什么&quot;&gt;&lt;a href=&quot;#NAT是什么&quot; class=&quot;headerlink&quot; title=&quot;NAT是什么&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="网络" scheme="https://nijiehaha.github.io/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="网络" scheme="https://nijiehaha.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>第一次写博客</title>
    <link href="https://nijiehaha.github.io/2018/09/07/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
    <id>https://nijiehaha.github.io/2018/09/07/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</id>
    <published>2018-09-07T07:55:27.000Z</published>
    <updated>2019-12-18T08:24:24.750Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于“我”"><a href="#关于“我”" class="headerlink" title="关于“我”"></a>关于“我”</h1><p>在下路小飞，喜欢《one piece》，但是苦于没发去伟大航路，好吧，我想在这里分享一些最近所学到的东西，为了记录，为了以后回忆～</p><h1 id="关于“今天”要做的"><a href="#关于“今天”要做的" class="headerlink" title="关于“今天”要做的"></a>关于“今天”要做的</h1><p>能够每天都比昨天多知道一点，这样我就满足了，嘻嘻嘻</p><h1 id="以后"><a href="#以后" class="headerlink" title="以后"></a>以后</h1><p>接下来，我想在这里分享一些所见所得吧～～加油QAQ</p><p>咦，下面这个是我了没错～</p><p>下图出自《冰菓》的最后一集的最后一刻，美好就是需要像这样记录下来：</p><p><img src="/images/第一次写博客/路小飞.jpg" alt="路小飞.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;关于“我”&quot;&gt;&lt;a href=&quot;#关于“我”&quot; class=&quot;headerlink&quot; title=&quot;关于“我”&quot;&gt;&lt;/a&gt;关于“我”&lt;/h1&gt;&lt;p&gt;在下路小飞，喜欢《one piece》，但是苦于没发去伟大航路，好吧，我想在这里分享一些最近所学到的东西，为了记录，
      
    
    </summary>
    
    
      <category term="年少轻狂，幸福时光" scheme="https://nijiehaha.github.io/categories/%E5%B9%B4%E5%B0%91%E8%BD%BB%E7%8B%82%EF%BC%8C%E5%B9%B8%E7%A6%8F%E6%97%B6%E5%85%89/"/>
    
    
      <category term="年少轻狂，幸福时光" scheme="https://nijiehaha.github.io/tags/%E5%B9%B4%E5%B0%91%E8%BD%BB%E7%8B%82%EF%BC%8C%E5%B9%B8%E7%A6%8F%E6%97%B6%E5%85%89/"/>
    
  </entry>
  
</feed>
