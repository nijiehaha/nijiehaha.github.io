---
title: 知识小集
date: 2020-3-10 14:00:00
tags: 杂七杂八
categories: 杂七杂八
---

这里记录一些单个小知识，当备忘录用了，会持续更新，嘻嘻嘻。

> 持续交付的神器，[fastlane](https://docs.fastlane.tools/)真是太方便好用了，一个`gym`选项就满足了我的所有需求，苦笑～～～

> Postman好人性化啊，关于multipart/form-data和application/x-www-form-urlencoded的小区别～～～

> **PHImageManager**的`requestImageData`有一个巨坑（我没找到比较好的办法），就是无论如何都会阻塞主线程一会儿，但是只要在当前线程`sleep`任意时间，就没事了，相当硬核，或者直接使用`requestImage`这个api，速度快，`PHImageRequestOptions`设置成同步，效果佳，很香

> hexo在远程git仓库，更改密码，无法推送，也不弹出密码，用户名的情况下，可以考虑删除hexo根目录下的`.deploy`文件夹

> iOS，实现镂空的效果，可以使用`CALayer`的[mask](https://developer.apple.com/documentation/quartzcore/calayer/1410861-mask)和[contents](https://developer.apple.com/documentation/quartzcore/calayer/1410773-contents)，或者直接使用`UIView`的[mask](https://developer.apple.com/documentation/uikit/uiview/1622557-mask)，我自己觉得最简单的是使用`UIBezierPath`的方法[reversing()](https://developer.apple.com/documentation/uikit/uibezierpath/1624348-reversing)，这个方法实现镂空，我个人觉得最巧妙了，当然还有其他的方法，都有点麻烦，比如利用`drawRect`来渲染绘制出来

> `swift`5.0之后，关于[正则表达式](https://deerchao.cn/tutorials/regex/regex.htm)，有一个新的很方便的语法糖`#`，举个例子，类似这样：`#"\dlufei\d"#`，不需要再使用转移字符了，点赞

> 在`swift`中，要想使用正则表达式，一般使用[NSRegularExpression](https://developer.apple.com/documentation/foundation/nsregularexpression)，还可以使用`String`的[range(of:)](https://developer.apple.com/documentation/foundation/nsstring/1410144-range)接口，[参考Mattt大神的文章](https://nshipster.com/swift-regular-expressions/)<br>
当然，还可以使用[模式匹配（pattern-match）](https://docs.swift.org/swift-book/ReferenceManual/Patterns.html)来为`NSRegularExpression`提供方便的扩展，[参考喵神文章](https://swifter.tips/pattern-match/)

> `swift`的[核心库](https://swift.org/core-libraries/#foundation)是包含*Foundation*框架的，不过这个库是独立于`Objective-C runtime`来使用swift重新构建的

> **Swift**中的[Range](https://developer.apple.com/documentation/swift/range)，表示从下限到上限（但不包括上限）的半开间隔，举个例子：`0.0..<5.0`，这就是一个简单的**Range**，[ColsedRange](https://developer.apple.com/documentation/swift/closedrange), 表示一个从下限到上限（包括上限）的间隔，举个例子：`0...5`，`Partial`开头的区间表示单方向的区间

> **Swift**中的语法糖，形如`String[Range]`，可以直接截取字符串，这是在标准库里，`Sring`中专门实现了**subscript(r:Range<String.Index>) -> subString**

> iOS9.0以后，[SFSafariViewController](https://developer.apple.com/documentation/safariservices/sfsafariviewcontroller)可以实现和safari的cookies共享，这个其实就给需要实现下载归因记录的需求的人（这个需求，还可以通过ip，网络状况，设备信息来匹配的方法，来判断来源，不管哪种方法都是需要下载并打开应用才行），提供了另一个思路，可以通过cookies来追踪来源，js的唤醒方法一般是用[Location](https://www.w3schools.com/js/js_window_location.asp)方法，app端则加载一个SFSafariViewController，大概是这样，当然这只是一个思路，貌似这个方案有被拒绝的可能，[审核指南](https://developer.apple.com/app-store/review/guidelines/#legal)，可以参考下下

> 利用假期学一下SwiftUI，按照官方文档写了个demo app，不过快完成的时候发现一个惊人的问题，[NavigationLink](https://developer.apple.com/documentation/swiftui/navigationlink)只能响应一次，我以为我初学，对文档理解错误，一直没怀疑是Xcode11.3.1的bug，查了半天，在这儿找到了能暂时解决这个问题的办法（多层嵌套依然有问题），[参考](http://t.cn/A6Po4uju)，最好等Xcode自己更新修复解决这个问题了，上面提到的那个硬核解决方案事实上不太适用，哎，本来对SwiftUI充满期待的，另外，不过我觉得SwiftUI的写法很容易一不小心造成多层嵌套的不太美观的代码。终于把我的demo改造成了SwiftUI+Combine+MVVM了，还是有些成就感的～

> hexo要是换电脑了咋办，我最近遇到了这个小问题，仔细想了一下，最好的办法就是在远程博客仓库建个分支hexo-migrate，这样是最省事的吧？哈哈，赶紧记下来～

> 使用[AutoLayout](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/index.html)布局的时候，在某些场景下需要知道约束下的具体大小（比如动态计算cell等场景），此时可以使用apple提供的接口[systemLayoutSizeFittingSize](https://developer.apple.com/documentation/uikit/uiview/1622624-systemlayoutsizefitting)来获取

> Swift在处理复杂场景的时候（比如网络请求，要对同一个URLRequest做分门别类的处理），参考官方api的做法和[喵神的视频](https://www.youtube.com/watch?v=Xk4HZfW6vK0&list=PLJN8Q2M8xECkvIbNFM30Bu91qbN92SXND&index=14)，可以采用下面这样的优雅的方式：
```
struct AnyAdapter {
        
    let block: (URLRequest) throws -> URLRequest
    
    func adapter(_ req: URLRequest) throws -> URLRequest {
        return try block(req)
    }
        
}
    
enum MethodType {
        
    case get
    case post
        
    var adapter: AnyAdapter {
            
        return AnyAdapter { (req) -> URLRequest in
            return req
        }
            
    }
        
}

let method = MethodType.get

/// 调用
_ = try method.adapter.adapter(req)
```

> [WKWebView](https://developer.apple.com/documentation/webkit/wkwebview?language=objc)中加载本地html的时候，一定要使用相对路径文件夹，也就是在xcode显示为蓝色文件夹，代码示例：
> 
> {% codeblock lang:oc %}
NSURL *url = [[NSBundle mainBundle] URLForResource:@"localFile" withExtension:@"html" subdirectory:@"HtmlDirectory"];
NSURL *mainUrl = [[NSBundle mainBundle] bundleURL];
[self.wkWebView loadFileURL:url allowingReadAccessToURL:mainUrl]; 
{% endcodeblock %}
> 
> 无论哪一种load方式，只有相对路径的文件夹，css，js，图片等资源文件才能被正确加载，也才能被正确显示。  
> [参考](https://www.jianshu.com/p/1688c11af71c)

> iOS上的`quick action`提供了不错的小窗口，[官方教程](https://developer.apple.com/documentation/uikit/menus_and_shortcuts/add_home_screen_quick_actions)说的也挺细，不过，一旦你是iOS13并且用了`SceneDelegate`来管理生命周期的时候，你会发现，那篇教程有些对不上，事实上，在[SceneDelegate](https://developer.apple.com/documentation/uikit/uiscenedelegate)中有两个新的api来处理这些，并且最好忘了`AppDelegate`吧，它不值得。

> pod管理第三方的情况下，如果某个第三方支持多种你当前项目不需要的cpu架构，可以通过[post_install](https://guides.cocoapods.org/syntax/podfile.html#post_install)来移除冗余的部分

> 查单词的多种意思，可以在[韦氏词典](https://www.merriam-webster.com/)查询，试了几个，挺全面的，方便学习

> *Swift* 里面的 `String` 的 `index` 和 `count` 不是一一对应的（兼容 `Unicode`），所以 `stirng.count == 0` 的效率不如 `string.isEmpty`。

> 推荐iOS优雅引用资源的第三方库 [R.Swift](https://github.com/mac-cain13/R.swift) ,虽然不是全部，但已经解决了大多数需要硬编码的情况了，体验了一下，真香<br>
*原理浅析*：源码中引入了两个库 [Commander](https://github.com/kylef/Commander.git)和 [XcodeEdit](https://github.com/tomlokhorst/XcodeEdit), 第一个是用来在 `Swift` 中快速方便地构造命令行接口，第二个就是用来获取工程项目下的资源信息，最后把拿到的资源信息整合成一个字符串，然后在 `R.generate.swift`文件中拼装成规律的 `Swift` 结构体。

> Swift 的 Array 获取 索引的其中一个办法是 [indices](https://developer.apple.com/documentation/swift/array/2994726-indices)

> [Git](https://git-scm.com/book/zh/v2/%E8%B5%B7%E6%AD%A5-%E5%88%9D%E6%AC%A1%E8%BF%90%E8%A1%8C-Git-%E5%89%8D%E7%9A%84%E9%85%8D%E7%BD%AE) 使用过程中，如果有两个账号，并且是使用用户名密码登录的情况下，需要了解一下 [更新 OSX 密钥链中的凭据](https://help.github.com/cn/github/using-git/updating-credentials-from-the-osx-keychain), [在 Git 中缓存 GitHub 密码](https://help.github.com/cn/github/using-git/caching-your-github-password-in-git), [删除 credential.helper=osxkeychain](https://gist.github.com/ramingar/a5789a2323c3b2d59edd34d87e32ef19)，并且 Mac 上的 git 默认就有这个 `credential.helper=osxkeychain` 的设置，并且我还没有找到这句话到底写在哪个配置文件下，悲伤～